<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="本篇博客记录了java相关的知识点">
<meta name="keywords" content="冰断秋">
<meta property="og:type" content="article">
<meta property="og:title" content="java复习与查缺补漏">
<meta property="og:url" content="http://yoursite.com/2019/06/20/java复习与查缺补漏/index.html">
<meta property="og:site_name" content="但行己路，莫问他人">
<meta property="og:description" content="本篇博客记录了java相关的知识点">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-09-19T03:33:25.039Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java复习与查缺补漏">
<meta name="twitter:description" content="本篇博客记录了java相关的知识点">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/06/20/java复习与查缺补漏/">





  <title>java复习与查缺补漏 | 但行己路，莫问他人</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">但行己路，莫问他人</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/20/java复习与查缺补漏/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冰断秋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="但行己路，莫问他人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java复习与查缺补漏</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-20T17:47:40+08:00">
                2019-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>本篇博客记录了java相关的知识点</strong><br><a id="more"></a></p>
<h1 id="JAVA基础知识"><a href="#JAVA基础知识" class="headerlink" title="JAVA基础知识"></a>JAVA基础知识</h1><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li>使用try..catch..finally来捕获异常，使用throw可以在方法体里抛出异常，在声明方法时通过添加throws关键词可以在调用这个方法时必须try..catch或者继续往上抛。可以通过继承Execption类来创建自定义异常类。可以通过printStackTrace来打印异常信息。当运行到抛出异常的代码时，后边的代码就不会再执行。</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>Java中的字符串具有不变形，每次试图改变字符串时都是创建了一个新的字符串对象。如果要频繁修改字符串，应使用StringBuilder类。</li>
<li>String类的常用方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int length()    返回当前字符串的长度。</span><br><span class="line"></span><br><span class="line">int indexOf(char/String ch/str)	返回ch/str在字符串中第一次出现的位置。</span><br><span class="line"></span><br><span class="line">int lastIndexOf(char/String ch/str)   返回ch/str在字符串中最后一次出现的位置。</span><br><span class="line"></span><br><span class="line">String substring(int beginIndex,int endIndex)   获取从begin开始到end结束的字符串</span><br><span class="line"></span><br><span class="line">String substring(int beginIndex)  获取从begin开始到结尾的字符串</span><br><span class="line">1. char charAt(int index)   获取字符串中指定位置的字符</span><br><span class="line"></span><br><span class="line">String[] split(String regex,int limit) 分割字符串</span><br><span class="line"></span><br><span class="line">byte[]  getBytes()	将字符串转换为byte数组</span><br></pre></td></tr></table></figure>
<h2 id="时间和日期的处理"><a href="#时间和日期的处理" class="headerlink" title="时间和日期的处理"></a>时间和日期的处理</h2><ul>
<li>使用Calendar类进行时间和日期的处理：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通过getlnstance()来获取Calendar的实例</span><br><span class="line"></span><br><span class="line">通过 get(Calendar.YEAR/MONTH/MINUTE..)来获取年月日等，创建一个int来接受返回值。</span><br><span class="line">// Calendar常用方法</span><br><span class="line">Date getTime() 获取Calendar的Date对象。</span><br><span class="line"></span><br><span class="line">Long getTimeInMillis()  获取此Calendar的时间值，以毫秒为单位。</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用SimpleDateFormat类初始化日期格式</li>
</ul>
<h2 id="Math类的常用方法"><a href="#Math类的常用方法" class="headerlink" title="Math类的常用方法"></a>Math类的常用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long round()  返回四舍五入后的整数</span><br><span class="line"></span><br><span class="line"> double floor()  返回小于参数的整数</span><br><span class="line"></span><br><span class="line"> double ceil()   返回大于参数的整数</span><br><span class="line"></span><br><span class="line"> double random()  返回[0,1]之间的随机数</span><br></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li><p>泛型集合可以添加泛型的子类对象。</p>
</li>
<li><p>集合可以使用contins(Object o)方法判断当前集合是否有对象o</p>
</li>
<li><p>判断set集合时需要重写equals和hashCode方法</p>
</li>
<li><p>集合中的sort方法判断字符串时会根据首字母依次往后推来判断，从大到小为：0-9,A-Z，a-z</p>
</li>
<li><p>Collection.sort()方法中的形参如果是引用类型，则必须实现Comparable借口</p>
<h2 id="java中的进制"><a href="#java中的进制" class="headerlink" title="java中的进制"></a>java中的进制</h2><p><strong>Java中的进制转换方法都是在integer这个类里边，十进制转其他进制使用toXXXX方法。其他进制转十进制使用parseInt方法</strong></p>
<p>Java中的数据类型所占字节分别是：1个字节是8bit，byte(8bit, -128-127)、short(16bit)、int(32bit)、long(64bit)、单精度(32bit,float)、双精度(64bit,double)、boolean(8bit)、char（Unicode，16bit）</p>
</li>
</ul>
<h2 id="io流"><a href="#io流" class="headerlink" title="io流"></a>io流</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul>
<li>gbk编码中文占用2个字节，英文占用1个，utf-8中文占用3个，英文占用2个，utf-16be中文和英文都是两个字节。当字节序列是某种编码时，解析这个字节序列也必须是这种编码。</li>
</ul>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p><strong>File类只用于表示文件的信息，不能用于访问文件</strong></p>
<h4 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">exists（）  判断调用这个方法的对象存不存在</span><br><span class="line"></span><br><span class="line">mkdir（）   创建文件夹。</span><br><span class="line"></span><br><span class="line">mkdirs（）  创建多个文件夹</span><br><span class="line"></span><br><span class="line">separator  静态属性，设置分割符</span><br><span class="line"></span><br><span class="line">isDirectory（）  判断是否是目录。不是目录或目录不存在返回false</span><br><span class="line"></span><br><span class="line">ifFile（）  是否是一个文件。</span><br><span class="line"></span><br><span class="line">getParent（） 获得父目录。</span><br><span class="line"></span><br><span class="line">list（）  用于列出当前目录下的子目录和文件，不包含子目录下的文件。</span><br></pre></td></tr></table></figure>
<h3 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h3><p>  <strong>RandomAccessFile类是java提供的读写文件的类，它还支持随机读写文件。</strong>在硬盘上文件是byte储存的，是数据的集合。在调用RandomAccessFile类的构造方法时，除了要给File类，还有指定打开方式，包括”rw”(读写)以及”r”(只读)。在打开文件时，文件指针在开头，point = 0。RandomAccessFile类提供了读和写的方法，分别是write()以及read()，需要注意的是读写方法都是只读写一个字节。文件读写完成以后一定要关闭。raf在读取文件之前一定要把文件指针用seek方法设置到0</p>
<h3 id="字节流与字符流"><a href="#字节流与字符流" class="headerlink" title="字节流与字符流"></a>字节流与字符流</h3><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p><strong>InputStream是字节输入流，用来读取文件的内容。OutputStream是输出流，用来往文件写内容。这两个类是所有字节输入输出流的父类</strong></p>
<h5 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h5><h6 id="InputStream的读方法："><a href="#InputStream的读方法：" class="headerlink" title="InputStream的读方法："></a>InputStream的读方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   read()  返回一个读取到的字节(byte)</span><br><span class="line"></span><br><span class="line">read(byte[] b)  把读取到的字节直接填充到字节数组里</span><br><span class="line"></span><br><span class="line">read(byte[] b，int start,int size)  把读取到的字节从数组的start位置开始放size个</span><br></pre></td></tr></table></figure>
<h6 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h6><p><strong>fileInputStream继承自InputStream。主要实现了对文件的读操其中的read()方法返回的是读取到的有效字节的数量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream in = new FileInputStrea(fileName);</span><br><span class="line">   byte[] buf = new byte[10];</span><br><span class="line">   int bytes = 0;</span><br><span class="line">while((bytes = in.read(buf,0,buf.length)) != -1)&#123;</span><br><span class="line">   	for(int j = 0; j &lt; bytes; j++)&#123;</span><br><span class="line">       	System.out.print(Integer.toHexString(buf[j] &amp; 0xff) + &quot; &quot;);</span><br><span class="line">       	if (i++%10==0)&#123;</span><br><span class="line">           	System.out.println();</span><br><span class="line">       	&#125;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h5><h6 id="OutputStream的写方法："><a href="#OutputStream的写方法：" class="headerlink" title="OutputStream的写方法："></a>OutputStream的写方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">write(int b) 把b的低八位写入到流</span><br><span class="line"></span><br><span class="line">write(byte[] bt)  把字节数组bt写入到流</span><br><span class="line"></span><br><span class="line">write(byte[] be, int start, int size)  把字节数组be从start开始写size个到流</span><br></pre></td></tr></table></figure>
<h6 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h6><p><strong>实现了对文件的写操作。当创建FileOutputStream的对象时，如果文件不存在则创建，存在则删除掉重新创建。如果不想重新创建，则需要把append设为true。当调用write方法时只写入低八位。</strong></p>
<h5 id="使用字节流实现复制文件："><a href="#使用字节流实现复制文件：" class="headerlink" title="使用字节流实现复制文件："></a>使用字节流实现复制文件：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void copyFile(File srcFile, File destFile)throws IOException&#123;</span><br><span class="line">       if (!srcFile.exists())&#123;</span><br><span class="line">           throw new IllegalArgumentException(srcFile + &quot;不存在&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (!srcFile.isFile())&#123;</span><br><span class="line">           throw new IllegalArgumentException(srcFile + &quot;不是一个有效文件&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       FileInputStream in = new FileInputStream(srcFile);</span><br><span class="line">       FileOutputStream out = new FileOutputStream(destFile);</span><br><span class="line">       byte[] buf = new byte[20 * 1024];</span><br><span class="line">       int i;</span><br><span class="line">       while ((i = in.read(buf,0,buf.length)) != -1)&#123;</span><br><span class="line">           out.write(buf,0,i);</span><br><span class="line">           out.flush();</span><br><span class="line">       &#125;</span><br><span class="line">       in.close();</span><br><span class="line">       out.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>字节流读写方法中每次读取或写入一个数组的方法读取或写入速度最快。</strong></p>
<h5 id="数据字节流"><a href="#数据字节流" class="headerlink" title="数据字节流"></a>数据字节流</h5><p> <strong>数据字节流DateInputStream与DateOutputStream，dis与dos是对普通流的一个扩展，用于方便的读写数据。使用了装饰模式，调用dis与dos的构造方法时需要对应的输入输出流。dis&amp;dos相比原本的输入输出流可以直接写入或读取基本数据类型。不需要自己在手写实现。</strong></p>
<h5 id="带缓冲区的字节流"><a href="#带缓冲区的字节流" class="headerlink" title="带缓冲区的字节流"></a>带缓冲区的字节流</h5><p> <strong>带缓冲区的字节流BufferedInputStream&amp;BufferedOutputStream，bis&amp;bos相比于原本的io流与数据io流提供了带缓冲区的io流，原本的io流当调用写入或读取方法时，直接操作内存，而带缓冲区的io流则会吧数据存入缓冲区，当缓冲区满或者调用flush()时在写入内存。所以当写入数据较少时如果不调用flush()方法就不会写入。</strong></p>
<p> 创建一个带缓冲区的字节流：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));</span><br><span class="line">   BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile,true));</span><br><span class="line">   int i = 0;</span><br><span class="line">   while((i = bis.read()) != -1)&#123;</span><br><span class="line">       bos.write(i);</span><br><span class="line">       bos.flush();</span><br><span class="line">   &#125;</span><br><span class="line">   bis.close();</span><br><span class="line">   bos.close();</span><br></pre></td></tr></table></figure></p>
<p>缓冲读取相对于批量读取减少了操作内存的次数。可以用System类的currentTimeMills方法来获取当前毫秒数，在方法开始前获取一次，方法结束后在获取一次，获取后的减去获取前的就是方法运行所需的毫秒数。</p>
<h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p><strong>字符流是用来处理文本文件的io流，java的文本(char) 是16位无符号整数，是字符的unicode编码。而文件是byte byte byte的数据序列。文本文件是文本(char)按照某种编码序列化位byte储存的文件。字符流一次处理一个字符(char),底层仍然是字节流。</strong></p>
<h5 id="字符流的基本实现"><a href="#字符流的基本实现" class="headerlink" title="字符流的基本实现"></a>字符流的基本实现</h5><p> <strong>InputStreamRader与OutputStreamWriter其中Input完成byte解析为char，output完成char解析为byte。当调用InputStreamReader的构造方法时可以指定编码格式。</strong></p>
<p>应用InputStreamRader读取文件内容并打印到控制台：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = new InputStreamReader(new FileInputStream(new File(</span><br><span class="line">          &quot;E:\\java\\imooc\\Day01\\imooc.iml&quot;)));</span><br><span class="line">  int i = 0;</span><br><span class="line">  char[] buf = new char[8 * 1024];</span><br><span class="line">  while((i = isr.read(buf,0,buf.length)) != -1)&#123;</span><br><span class="line">      System.out.println(new String(buf,0,i));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="FileReade与FileWrited"><a href="#FileReade与FileWrited" class="headerlink" title="FileReade与FileWrited"></a>FileReade与FileWrited</h5><p> <strong>fr与fw是针对文件的字符流读写类，但是要注意的是在创建这两个类的对象时不能指定编码格式，默认使用项目的编码。所有有时候会导致乱码问题。</strong></p>
<h5 id="字符流过滤器"><a href="#字符流过滤器" class="headerlink" title="字符流过滤器"></a>字符流过滤器</h5><p> <strong>bufferReader与BufferWrite是对InputStreamRader与OutputStreamWriter的增强。过滤器相对于原来的字符流提供了缓冲区，需要注意的是读的时候并不能识别换行，在写文件的时候需要调用newLine方法来换行。</strong></p>
<h5 id="打印流：PrintWriter"><a href="#打印流：PrintWriter" class="headerlink" title="打印流：PrintWriter"></a>打印流：PrintWriter</h5><p>应用打印流读取文件并输出到控制到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;E:\\java\\imooc\\Day01\\imooc.iml&quot;));</span><br><span class="line"></span><br><span class="line">  PrintWriter pw = new PrintWriter(&quot;demo/imooc.txt&quot;);</span><br><span class="line">  String line;</span><br><span class="line">  while((line = br.readLine()) != null)&#123;</span><br><span class="line">      System.out.println(line);</span><br><span class="line">      pw.println(line);</span><br><span class="line">      pw.flush();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  br.close();</span><br><span class="line">  pw.close();</span><br></pre></td></tr></table></figure></p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><h3 id="序列化基础"><a href="#序列化基础" class="headerlink" title="序列化基础"></a>序列化基础</h3><p> <strong>对象序列化就是把一个Object转换成byte序列储存，反之就叫做反序列化。Java中实现序列化的io流是ObjectOutputStream与ObjectInputStream类它们是字节的过滤流，一个对象要进行序列化，必须要实现序列化接口。对象序列化就是把对象储存起来。</strong></p>
<p> 对象序列化的代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"> File f = new File(&quot;demo/student.txt&quot;);</span><br><span class="line">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(f));</span><br><span class="line"> Student sd = new Student(1,&quot;a&quot;,18);</span><br><span class="line"> oos.writeObject(sd);</span><br><span class="line"> oos.close();</span><br><span class="line"> ObjectInputStream ois = new ObjectInputStream(new FileInputStream(f));</span><br><span class="line"> Object o = ois.readObject();</span><br><span class="line"> if (o instanceof Student)&#123;</span><br><span class="line">     Student stu = (Student) o;</span><br><span class="line">     System.out.println(stu);</span><br><span class="line"> &#125;</span><br><span class="line"> ois.close();</span><br></pre></td></tr></table></figure>
<p><strong>在对象序列化时用transient修饰的属性不会进行jvm默认的序列化，但是可以自己完成属性的序列化,transient一般用来提高序列化性能。</strong>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private transient int stuAge;</span><br><span class="line">private void writeObject(java.io.ObjectOutputStream s)throws java.io.IOException&#123;</span><br><span class="line">      s.defaultWriteObject();</span><br><span class="line">      s.writeInt(stuAge);</span><br><span class="line">   &#125;</span><br><span class="line">   private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">          throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">      s.defaultReadObject();</span><br><span class="line">      stuAge = s.readInt();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是自定义对象序列化的读写时，先写哪个参数就会先读哪个参数。</strong></p>
<h3 id="序列化中子类父类构造方法"><a href="#序列化中子类父类构造方法" class="headerlink" title="序列化中子类父类构造方法"></a>序列化中子类父类构造方法</h3><p> 当一个类实现了序列化接口，它的子类都可以实现序列化，当一个子类进行序列化时，会递归调用父类的构造方法，当一个子类被反序列化时，会递归调用父类没有实现序列化接口的构造方法。原因是如果父类实现了序列化接口，在序列化时会把父类的构造方法也序列化，反之则会在反序列化时调用父类的构造方法。</p>
<h1 id="Java中的XML"><a href="#Java中的XML" class="headerlink" title="Java中的XML"></a>Java中的XML</h1><p> <strong>xml文件常用来数据存储于传输。xml文件的存储是以树形结构存储的，每个节点可以有属性，节点名称区分大小写。xml文件要在文件首句声明，声明形式为：<br>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</strong></p>
<p>xml应用于不同应用、软件、平台之间的通信，Java中可以使用DOM、SAX、DOM4J、JDOM解析4中方法，前两种是Java官方提供的方式，DOM4J及JDOM需要额外的下载Jar包并添加到项目中。</p>
<h2 id="XML读取"><a href="#XML读取" class="headerlink" title="XML读取"></a>XML读取</h2><h3 id="如何在Java中保留xml的结构"><a href="#如何在Java中保留xml的结构" class="headerlink" title="如何在Java中保留xml的结构"></a>如何在Java中保留xml的结构</h3><p> 创建一个类，类的属性与xml的节点属性相对应，然后在解析的时候创建这个类的实例并把解析出来的节点存到类里。</p>
<h3 id="常用的节点类型及方法的返回值"><a href="#常用的节点类型及方法的返回值" class="headerlink" title="常用的节点类型及方法的返回值"></a>常用的节点类型及方法的返回值</h3><table>
<thead>
<tr>
<th>节点类型</th>
<th>nodeName返回值</th>
<th>nodeValue返回值</th>
<th>NodeType</th>
<th>NamedConstant </th>
</tr>
</thead>
<tbody>
<tr>
<td>Element</td>
<td>ElementName</td>
<td>null</td>
<td>1</td>
<td>ELEMENT_NODE</td>
</tr>
<tr>
<td>Attr</td>
<td>属性名称</td>
<td>属性值</td>
<td>2</td>
<td>ATTR_NODE</td>
</tr>
<tr>
<td>Text</td>
<td>#text</td>
<td>节点内容</td>
<td>3</td>
<td>TEXT_NODE</td>
</tr>
</tbody>
</table>
<h3 id="DOM方式解析XML文件"><a href="#DOM方式解析XML文件" class="headerlink" title="DOM方式解析XML文件"></a>DOM方式解析XML文件</h3><ol>
<li>首先取得xml文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//通过DocumentBuilderFactory的静态方法创建一个DocumentBuilderFactory对象</span><br><span class="line">   DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">   //通过DocumentBuilderFactory对象创建一个DocumentBuilder对象</span><br><span class="line">   DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">   //通过DocumentBuilder对象解析xml文件</span><br><span class="line">   Document d = db.parse(&quot;demo/books.xml&quot;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>以book节点为例，取得book节点的所有属性并遍历：</li>
</ol>
<p>在不知道节点的属性个数及名字的情况下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//通过标签名字获取标签集合</span><br><span class="line">   NodeList books = d.getElementsByTagName(&quot;book&quot;);</span><br><span class="line">      //遍历标签集合</span><br><span class="line">      for (int i = 0; i &lt; books.getLength(); i++)&#123;</span><br><span class="line">          //获取标签</span><br><span class="line">          Node n = books.item(i);</span><br><span class="line">          //获取标签的所有属性</span><br><span class="line">          NamedNodeMap nnm =  n.getAttributes();</span><br><span class="line">          //遍历标签的属性并输出属性名和属性值</span><br><span class="line">          for(int j = 0; j &lt; nnm.getLength(); j++)&#123;</span><br><span class="line">              System.out.println(&quot;名字&quot; + nnm.item(j).getNodeName() + &quot;属性&quot; + nnm.item(j).getNodeValue() );</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>  在知道属性名字的情况下，可以通过属性名字获取属性值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//通过标签名字获取标签集合</span><br><span class="line">   NodeList books = d.getElementsByTagName(&quot;book&quot;);</span><br><span class="line">      //遍历标签集合</span><br><span class="line">      for (int i = 0; i &lt; books.getLength(); i++)&#123;</span><br><span class="line">	  //如果标签集合中的成员不能转换为Element则抛出异常</span><br><span class="line">         if (!(books.item(i) instanceof Element))&#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;111&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         //把标签集合中的成员转换为Element</span><br><span class="line">          Element book =(Element) books.item(i);</span><br><span class="line">         //通过Element的getAttribute方法获得属性名为ID的属性值</span><br><span class="line">          String val = book.getAttribute(&quot;name&quot;);</span><br><span class="line">          System.out.println(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>解析子节点</li>
</ol>
<p>以book节点为例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> NodeList books = d.getElementsByTagName(&quot;book&quot;);</span><br><span class="line">    //遍历节点集合</span><br><span class="line">    for (int i = 0; i &lt; books.getLength(); i++)&#123;</span><br><span class="line">         //获取第i个book节点</span><br><span class="line">         Node book = books.item(i);</span><br><span class="line">         //获取book节点的子节点</span><br><span class="line">         NodeList childs = book.getChildNodes();</span><br><span class="line">         //遍历子节点</span><br><span class="line">         for(int k = 0; k &lt; childs.getLength(); k++)&#123;</span><br><span class="line">             //取得第k个子节点</span><br><span class="line">             Node child = childs.item(k);</span><br><span class="line">             //判断子节点是否为Element类型，如果是则输出节点名字与节点文本</span><br><span class="line">             if (child.getNodeType() == Node.ELEMENT_NODE)&#123;</span><br><span class="line">                 //输出节点名字</span><br><span class="line">                 System.out.print(child.getNodeName());</span><br><span class="line">                 //输出节点文本</span><br><span class="line">                 System.out.println(child.getFirstChild().getNodeValue());</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是直接使用getNodeValue()方法，获取不到文本值，这是因为把book的文本内容当做了一个子节点，所有要在使用getFirstChild()方法获取book的第一个子节点，在获取这个子节点的值。当book方法有多个子节点且第一个子节点也是Element，会获取不到文本值。</strong></p>
<p>还有另一种方法获取文本：这个方法时获取book节点的子节点中的所有文本值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(child.getTextContent());</span><br></pre></td></tr></table></figure>
<p><strong>两种方法的区别是前者是获取子节点的value值，后者是获取子节点中的所有文本值。</strong></p>
<h3 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h3><p> <strong>DOM解析与SAX解析的不同，DOM解析会把整个XML文件加载到内存中，然后逐个解析，SAX解析是通过Handler类按顺序逐个解析节点。SAX解析在碰到开始标签是会调用startElement方法，结束标签会调用endElement方法</strong></p>
<p> <strong>在创建SAX解析器对象后调用parse()方法发现需要创建一个DefaultHandler的对象，DefaultHandler类中的startElement方法是当解析到开始标签要做什么，而SAXParser的parse方法是解析xml文件的</strong></p>
<h4 id="SAX解析XML文件"><a href="#SAX解析XML文件" class="headerlink" title="SAX解析XML文件"></a>SAX解析XML文件</h4><ol>
<li><p>创建SAX解析的实例并获取XML文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SAXParserFactory saxFactory = SAXParserFactory.newInstance();</span><br><span class="line"></span><br><span class="line">   SAXParser parser = saxFactory.newSAXParser();</span><br><span class="line">   DefaultHandler dh = new SAXParserHandler();</span><br><span class="line">   parser.parse(&quot;demo/books.xml&quot;,dh);</span><br></pre></td></tr></table></figure>
</li>
<li><p>SAX解析获得属性值以及属性名：</p>
<p><strong>当已知标签属性的名字及个数时,可以直接使用getValue方法获得属性的值。</strong></p>
</li>
</ol>
<p>当不知道属性名及个数时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> for (int i = 0; i &lt; attributes.getLength(); i++)&#123;</span><br><span class="line">    //获得属性值</span><br><span class="line">    System.out.println(attributes.getValue(i));</span><br><span class="line">    //获得属性值</span><br><span class="line">    System.out.println(attributes.getQName(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>SAX解析获得节点名及节点值并不输出空格与换行：</p>
<p><strong>每当遇到一个新的开始节点，qName就是当前节点名。而character就是当前的节点值。需要注意的是空格与换行也会被解析为节点，所以空格与换行也会被输出。</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String str = new String(ch,start,length);</span><br><span class="line">if (!(&quot;&quot;.equals(str.trim())))&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SAX解析中defaultHandler的方法调用顺序，首先是startDocument、startEmelent、characters、endEmelent、endDocument，其中startEmelent获取节点名、节点属性。characters获取节点内容。</strong></p>
<h3 id="JDOM解析"><a href="#JDOM解析" class="headerlink" title="JDOM解析"></a>JDOM解析</h3><p><strong>JDOM不是官方提供的解析方式，所以要导入额外的jar包。+ 项目中jar包需要创建一个lib文件夹用来存放。</strong></p>
<ol>
<li>JDOM解析Xml文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SAXBuilder sax = new SAXBuilder();</span><br><span class="line">   Document document = sax.build(new FileInputStream(&quot;demo/books.xml&quot;));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>JDOM获取节点属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> //获取根节点</span><br><span class="line">Element rootElement = document.getRootElement();</span><br><span class="line">//通过根节点获取子节点</span><br><span class="line">List&lt;Element&gt; childred = rootElement.getChildren();</span><br><span class="line">//获取子节点的属性名以及属性值</span><br><span class="line">for(Element e : childred)&#123;</span><br><span class="line">    List&lt;Attribute&gt; attrib = e.getAttributes();</span><br><span class="line">    for (Attribute a : attrib</span><br><span class="line">         ) &#123;</span><br><span class="line">        //获取属性名</span><br><span class="line">        System.out.println(a.getName());</span><br><span class="line">        //获取属性值</span><br><span class="line">        System.out.println(a.getValue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>JDOM中的getValue方法不会获取空格与换行,在知道属性名字获取属性值时可以通过getAttributeValue方法传入属性名获取属性值</strong></p>
<ol start="3">
<li>JDOM获取节点名字与节点值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//获取子节点的子节点</span><br><span class="line">          List&lt;Element&gt; elements = e.getChildren();</span><br><span class="line">          //遍历子节点集合</span><br><span class="line">          for (Element ele : elements</span><br><span class="line">               ) &#123;</span><br><span class="line">              //获取子节点的名字</span><br><span class="line">              System.out.println(ele.getName());</span><br><span class="line">              //获取子节点的内容</span><br><span class="line">              System.out.println(ele.getValue());</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<h4 id="JDOM解析的中文乱码问题"><a href="#JDOM解析的中文乱码问题" class="headerlink" title="JDOM解析的中文乱码问题"></a>JDOM解析的中文乱码问题</h4><p> <strong>可能是xml文件的编码格式声明为不支持中文的编码，或者是解析时用不支持中文的编码来解析。xml文件中是encodeing属性声明编码格式的，而代码中可能是因为IO流解析时的编码问题。</strong></p>
<h3 id="DOM4J解析"><a href="#DOM4J解析" class="headerlink" title="DOM4J解析"></a>DOM4J解析</h3><ol>
<li>解析XML文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SAXReader sr = new SAXReader();</span><br><span class="line">Document document = sr.read(new FileInputStream(&quot;demo/books.xml&quot;));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>解析节点属性以及子节点</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">//获取根节点</span><br><span class="line">Element rootElement = document.getRootElement();</span><br><span class="line">//通过根节点获取子节点集合</span><br><span class="line">List&lt;Element&gt; books = rootElement.elements();</span><br><span class="line">//通过迭代器迭代子节点</span><br><span class="line">Iterator&lt;Element&gt; it = books.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">    Element element = it.next();</span><br><span class="line">    //获取子节点的属性集合</span><br><span class="line">    List&lt;Attribute&gt; attributes =  element.attributes();</span><br><span class="line">    for (Attribute a : attributes</span><br><span class="line">         ) &#123;</span><br><span class="line">        //属性名</span><br><span class="line">        System.out.println(a.getName());</span><br><span class="line">        //属性值</span><br><span class="line">        System.out.println(a.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    //获取子节点的子节点集合</span><br><span class="line">    List&lt;Element&gt; elements =  element.elements();</span><br><span class="line">    //遍历子节点</span><br><span class="line">    for (Element ele : elements</span><br><span class="line">         ) &#123;</span><br><span class="line">        //获取当前子节点的节点名</span><br><span class="line">        System.out.println(ele.getName());</span><br><span class="line">        //获取当前子节点的节点值</span><br><span class="line">        System.out.println(ele.getStringValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四种解析方式的分析以及解析速度对比"><a href="#四种解析方式的分析以及解析速度对比" class="headerlink" title="四种解析方式的分析以及解析速度对比"></a>四种解析方式的分析以及解析速度对比</h3><p><strong>java官方解析方式：DOM以及SAX，其中DOM是与语言无关的解析方式，而SAX是Java所独有的，JDOM以及DOM4J就是根据SAX扩展而来的，它们是第三方提供的解析方式。其中DOM4J相对JDOM来说，各方面都会好一点。</strong></p>
<p><strong>DOM解析：DOM解析会一次性的把XML文件写进内存中，并且形成一个DOM树，因为DOM会一次加载整个xml文件，所以当xml文件过大时，加载速度会过慢。并且对计算机运行内存也有要求。</strong></p>
<p><strong>SAX解析：SAX解析时一种基于事件的解析方式，所谓的基于事件的解析方式就是逐条语句解析的，然后判断是否符合某一个条件，如果是，则执行符合条件的方法。</strong></p>
<p><strong>通过观察四种解析速度的对比，sax解析速度最快，dom和jdom差不多，dom4j速度最慢。</strong></p>
<h2 id="XML写入"><a href="#XML写入" class="headerlink" title="XML写入"></a>XML写入</h2><p><strong>DOM与SAX是官方提供的XML文件的写入方法，会生成一个xml文件。DOM4J与JDOM是非官方提供的，会生成一个rss文件。</strong></p>
<h3 id="DOM写入"><a href="#DOM写入" class="headerlink" title="DOM写入"></a>DOM写入</h3><ol>
<li>生成DOM树</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> //创建DOM树</span><br><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">Document d = db.newDocument();</span><br><span class="line">//为DOM树添加节点</span><br><span class="line">Element book = d.createElement(&quot;book&quot;);</span><br><span class="line">Element rootNode = d.createElement(&quot;bookStore&quot;);</span><br><span class="line">d.appendChild(rootNode);</span><br><span class="line">rootNode.appendChild(book);</span><br><span class="line">//为DOM树中的book标签添加属性</span><br><span class="line">book.setAttribute(&quot;id&quot;,&quot;1&quot;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建xml文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">       // 生成xml文件</span><br><span class="line">      TransformerFactory tff = TransformerFactory.newInstance();</span><br><span class="line">      Transformer tf = tff.newTransformer();</span><br><span class="line">      // 设置是否换行</span><br><span class="line">      tf.setOutputProperty(OutputKeys.INDENT,&quot;yes&quot;);</span><br><span class="line">//生成文件</span><br><span class="line">      tf.transform(new DOMSource(d),new StreamResult(new File(&quot;demo/books1.xml&quot;)));</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>生成节点间的文本</li>
</ol>
<p><strong>需要注意的是Element类型的节点使用setNodeValue方法生成的节点间的文本为空，需要使用setTextContent方法。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // 生成节点间文本</span><br><span class="line">name.setTextContent(&quot;小王子&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="SAX生成XML文件"><a href="#SAX生成XML文件" class="headerlink" title="SAX生成XML文件"></a>SAX生成XML文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> //生成xml文件</span><br><span class="line">SAXTransformerFactory sff = (SAXTransformerFactory) SAXTransformerFactory.newInstance();</span><br><span class="line">// 获得TransformerHandler对象</span><br><span class="line">TransformerHandler tfh = sff.newTransformerHandler();</span><br><span class="line">//通过TransformerHandler对象的Transformer设置xml文件</span><br><span class="line">Transformer tf = tfh.getTransformer();</span><br><span class="line">tf.setOutputProperty(OutputKeys.INDENT,&quot;yes&quot;);</span><br><span class="line">tf.setOutputProperty(OutputKeys.ENCODING,&quot;GBK&quot;);</span><br><span class="line">// 创建一个结果流并关联到获得TransformerHandler对象里</span><br><span class="line">Result result = new StreamResult(new FileOutputStream(&quot;demo/books2.xml&quot;));</span><br><span class="line">tfh.setResult(result);</span><br><span class="line">// 生成节点及节点属性</span><br><span class="line">tfh.startDocument();</span><br><span class="line">// 属性</span><br><span class="line">AttributesImpl atts = new AttributesImpl();</span><br><span class="line">// 生成根节点并把属性解析进去</span><br><span class="line">tfh.startElement(&quot;&quot;,&quot;&quot;,&quot;bookStroe&quot;, atts);</span><br><span class="line">// 清除atts的值</span><br><span class="line">atts.clear();</span><br><span class="line">// 添加属性</span><br><span class="line">atts.addAttribute(&quot;&quot;,&quot;&quot;,&quot;id&quot;,&quot;&quot;,&quot;1&quot;);</span><br><span class="line">//在根节点下增加子节点，并把刚刚添加的属性解析进去</span><br><span class="line">tfh.startElement(&quot;&quot;,&quot;&quot;,&quot;book&quot;,atts);</span><br><span class="line">//清除 atts</span><br><span class="line">atts.clear();</span><br><span class="line">// 在子节点下增加字节点</span><br><span class="line">tfh.startElement(&quot;&quot;,&quot;&quot;,&quot;name&quot;,atts);</span><br><span class="line">// 为name子节点增加文本内容</span><br><span class="line">tfh.characters(&quot;小王子&quot;.toCharArray(),0,&quot;小王子&quot;.toCharArray().length);</span><br><span class="line">// 为每一个开始标签增加结束标签</span><br><span class="line">tfh.endElement(&quot;&quot;,&quot;&quot;,&quot;name&quot;);</span><br><span class="line">tfh.endElement(&quot;&quot;,&quot;&quot;,&quot;book&quot;);</span><br><span class="line">tfh.endElement(&quot;&quot;,&quot;&quot;,&quot;bookStroe&quot;);</span><br><span class="line">tfh.endDocument();</span><br></pre></td></tr></table></figure>
<p> <strong>需要注意的是，如果把设置xml文件放在关联结果流会导致设置xml文件失效。而把关联结果流放到生成节点与属性之后会有异常。</strong></p>
<h3 id="RSS文件"><a href="#RSS文件" class="headerlink" title="RSS文件"></a>RSS文件</h3><p>JDOM和DOM4J都会生成一个RSS文件，那么什么是RSS文件？RSS本质上还是xml文件，rss文件相对于xml文件会多一个rss根标签</p>
<h3 id="DOM4J生成rss文件"><a href="#DOM4J生成rss文件" class="headerlink" title="DOM4J生成rss文件"></a>DOM4J生成rss文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> //  创建document对象，代表xml文件</span><br><span class="line">Document document = DocumentHelper.createDocument();</span><br><span class="line">// 设置xml文件使自动换行且自动缩进</span><br><span class="line">OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class="line">// 添加节点并添加属性</span><br><span class="line">Element rss = document.addElement(&quot;rss&quot;).addAttribute(&quot;version&quot;,&quot;2.0&quot;);</span><br><span class="line">Element books = rss.addElement(&quot;bookstore&quot;);</span><br><span class="line">books.addElement(&quot;book&quot;).addAttribute(&quot;id&quot;,&quot;1&quot;).addElement(&quot;name&quot;).addText(&quot;小王子&quot;);</span><br><span class="line">// 生成xml文件</span><br><span class="line">XMLWriter writer = new XMLWriter(new FileOutputStream(new File(&quot;demo/dom4j.xml&quot;)),format);</span><br><span class="line">writer.write(document);</span><br></pre></td></tr></table></figure>
<p>生成RSS文件时处理转移字符：</p>
<p><strong>DOM4J对于需要转义的字符，已经自动处理了，而如果不想自动处理，则可以调用xml输出流的setEscapeTest方法设置为false</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">XMLwrite write = new XMLWrite();</span><br><span class="line">write.setEscapeTest(false);</span><br></pre></td></tr></table></figure>
<h3 id="JDOM生成XML文件"><a href="#JDOM生成XML文件" class="headerlink" title="JDOM生成XML文件"></a>JDOM生成XML文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // 创建DOM树并增加节点与属性</span><br><span class="line">Document document = new Document();</span><br><span class="line">Element rss = new Element(&quot;rss&quot;).setAttribute(&quot;version&quot;,&quot;2.0&quot;);</span><br><span class="line">Element books = new Element(&quot;bookstore&quot;);</span><br><span class="line">Element book = new Element(&quot;book&quot;).setAttribute(&quot;id&quot;,&quot;1&quot;);</span><br><span class="line">Element name = new Element(&quot;name&quot;);</span><br><span class="line">document.addContent(rss);</span><br><span class="line">rss.addContent(books);</span><br><span class="line">books.addContent(book);</span><br><span class="line">book.addContent(name);</span><br><span class="line">name.addContent(&quot;小王子&lt;&quot;);</span><br><span class="line">// 设置xml文件的编码格式与换行缩进</span><br><span class="line">Format format = Format.getPrettyFormat();</span><br><span class="line">format.setEncoding(&quot;utf-8&quot;);</span><br><span class="line">//  使xml文件不进行自动转义</span><br><span class="line">XMLOutputter output = new XMLOutputter(format)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String escapeElementEntities(String str) &#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 生成xml文件</span><br><span class="line">output.output(document,new FileOutputStream(new File(&quot;demo/jdom2.xml&quot;)));</span><br></pre></td></tr></table></figure>
<h3 id="生成方式的对比"><a href="#生成方式的对比" class="headerlink" title="生成方式的对比"></a>生成方式的对比</h3><p>DOM是基于树结构生成xml文件的，SAX是基于事件生成。JDOM与DOM4J是基于底层API生成的。DOM方式方便修改删除DOM树，但是性能较低，而SAX性能较高，但是不方便修改。</p>
<p><strong>四种生成方式性能对比：sax最快、jdom第二、dom4j第三、dom最慢</strong></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><p>网络编程：两台电脑如果要通信需要满足以下条件：</p>
<ol>
<li>两台主机要有唯一的标识也就是ip地址</li>
<li>要有共同的语言，也就是协议</li>
<li>要有相应的端口号，用来辨别不同应用程序</li>
</ol>
<p><strong>TCP/IP是目前应用最为广泛的协议，是以TCP和IP为基础的不同层次上多个协议的集合，两个主机要进行通信就要遵守TCP（传输控制协议）和IP（互联网协议）协议。</strong></p>
<p><strong>在实际应用中，会将网络分层，常见的会将网络分为5层，分别是应用层、传输层、网络层、数据链路层、物理层。 而TCP与IP实在第4层传输层，应用层是用户直接接触的，包括HTTP协议、FTP协议、SMTP协议、Telnet远程登录服务都是应用层的协议。</strong></p>
<p><strong>ip地址是每台计算机的唯一标示，目前使用较多的版本是IPV4，在这个版本中定义了IP地址的长度为32位的2进制</strong></p>
<p><strong>端口号是用来区分不同的应用程序，每一个应用都有唯一的端口号，用来标识不同的程序，端口号范围为0~65535，其中0~1023为系统所保留，自定义端口号最好使用1023以后的端口号。</strong></p>
<p><strong>IP地址和端口号就组成了所谓的Socket，Socket是网络上运行的程序之间双向通信链路的终结点，是TCP和UDP的基础。</strong></p>
<p>两台主机要互相通信，首先要知道对方的IP地址，知道对方的IP地址之后要知道对方的端口号。知道IP地址加端口号就能互相通信了</p>
<p><strong>常用的协议与其端口号：http：80；  ftp：21；  telnet：23</strong></p>
<h2 id="java中的网络通信"><a href="#java中的网络通信" class="headerlink" title="java中的网络通信"></a>java中的网络通信</h2><p>Java中针对网络通信的不同层次，提供了四大类。</p>
<ol>
<li>InetAddress： 用于标识网络上的硬件资源。比如IP地址</li>
<li>URL:统一资源定位符  通过URL可以读取或写入网络上的数据</li>
<li>Sockets： 使用TCP协议实现网络通讯</li>
<li>Datagram： 使用UDP协议，将数据保存在数据报中，进行网络通讯</li>
</ol>
<h2 id="Java中网络相关API"><a href="#Java中网络相关API" class="headerlink" title="Java中网络相关API"></a>Java中网络相关API</h2><h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> //获取本地主机</span><br><span class="line">InetAddress id = InetAddress.getLocalHost();</span><br><span class="line">// 获取主机地址</span><br><span class="line">System.out.println(id.getHostAddress());</span><br><span class="line">// 获取主机名字</span><br><span class="line">System.out.println(id.getHostName());</span><br><span class="line">// id就是主机名字加主机地址</span><br><span class="line">System.out.println(id);</span><br><span class="line">// 通过主机名字获取主机</span><br><span class="line">InetAddress id1 = InetAddress.getByName(&quot;PC&quot;);</span><br><span class="line">// 通过IP地址获取主机</span><br><span class="line">InetAddress id2 = InetAddress.getByAddress(id.getAddress());</span><br></pre></td></tr></table></figure>
<h3 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h3><p><strong>URL是表示网络上某一资源的地址，URL由两部分组成，协议名和资源名，中间用冒号隔开。</strong></p>
<p>使用url类获取网页内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建url实例，并指定网址</span><br><span class="line">   URL url = new URL(&quot;http://www.baidu.com&quot;);</span><br><span class="line">   // 使用输出流与openStream方法生成百度的主页内容</span><br><span class="line">   InputStream is = url.openStream();</span><br><span class="line">   FileOutputStream fos = new FileOutputStream(new File(&quot;demo/baidu.html&quot;));</span><br><span class="line">   byte[] b = new byte[8 * 1024];</span><br><span class="line">   while (is.read(b,0,b.length) != -1)&#123;</span><br><span class="line">       fos.write(b,0,b.length);</span><br><span class="line">       fos.flush();</span><br><span class="line">   &#125;</span><br><span class="line">   is.close();</span><br><span class="line">   fos.close();</span><br></pre></td></tr></table></figure>
<h3 id="基于TCP的网络编程"><a href="#基于TCP的网络编程" class="headerlink" title="基于TCP的网络编程"></a>基于TCP的网络编程</h3><p><strong>TCP协议是面向连接，它是可靠的、有序的，以字节流的方式发送数据。TCP在通信之前，需要建立连接，以保证数据传输的可靠性。在Java中使用Socket以及ServerSocket这两个类实现TCP通信的，其中Socket是客户端需要实现的，而ServerSocket是服务器端实现。</strong></p>
<h4 id="通过Socket实现TCP编程"><a href="#通过Socket实现TCP编程" class="headerlink" title="通过Socket实现TCP编程"></a>通过Socket实现TCP编程</h4><p><strong>Socket通信模顺序：Server建立服务端并等待请求，客户端创建连接并向服务端发送请求，服务端接受请求并创建连接，客户端与服务端使用io流开始通信，通信完毕关闭相关资源。</strong></p>
<p>代码实现：</p>
<p>客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建客户端Socket实例</span><br><span class="line">Socket socket = new Socket(&quot;192.168.17.1&quot;,9999);</span><br><span class="line">// 获取Socket中的输出流</span><br><span class="line">OutputStream os = socket.getOutputStream();</span><br><span class="line">// 往输出流中写入数据</span><br><span class="line">os.write(1);</span><br><span class="line">os.flush();</span><br><span class="line">// 获取Socket中的输入流</span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line">// 读取输入流中的数据</span><br><span class="line">int i ;</span><br><span class="line">while ((i = is.read()) != -1)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭资源</span><br><span class="line">socket.shutdownInput();</span><br><span class="line">socket.shutdownOutput();</span><br><span class="line">is.close();</span><br><span class="line">os.close();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>
<p>服务器端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建服务端的Socket对象</span><br><span class="line">ServerSocket ss = new ServerSocket(9999);</span><br><span class="line">// 监听端口</span><br><span class="line">Socket socket = ss.accept();</span><br><span class="line">// 获取Socket中的输出流</span><br><span class="line">OutputStream os = socket.getOutputStream();</span><br><span class="line">// 使用输入流写入数据</span><br><span class="line">os.write(2);</span><br><span class="line">// 获取Socket中的输入流</span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line">// 读取输入流中的数据</span><br><span class="line">int i;</span><br><span class="line">while((i = is.read()) != -1)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭资源</span><br><span class="line">socket.shutdownOutput();</span><br><span class="line">socket.shutdownInput();</span><br><span class="line">os.close();</span><br><span class="line">is.close();</span><br><span class="line">socket.close();</span><br><span class="line">ss.close();</span><br></pre></td></tr></table></figure>
<p><strong>在创建Socket对象时需要注意的是，需要先写后读，如果先读后写，会导致输出流写入的数据另一端不能正确接收到</strong></p>
<h4 id="使用多线程实现基于TCP的多客户端与服务器端通信"><a href="#使用多线程实现基于TCP的多客户端与服务器端通信" class="headerlink" title="使用多线程实现基于TCP的多客户端与服务器端通信"></a>使用多线程实现基于TCP的多客户端与服务器端通信</h4><p>服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // 创建服务端的Socket对象</span><br><span class="line">ServerSocket ss = new ServerSocket(9999);</span><br><span class="line">int count = 0;</span><br><span class="line">// 监听端口</span><br><span class="line">while (true) &#123;</span><br><span class="line">    // 监听端口，会堵塞当前线程，直到有监听结果</span><br><span class="line">    Socket socket = ss.accept();</span><br><span class="line">    // 创建线程类并准备运行</span><br><span class="line">    ServerThread st = new ServerThread(socket);</span><br><span class="line">    st.start();</span><br><span class="line">    // 客户端数量</span><br><span class="line">    System.out.println(&quot;当前有&quot; + (++count) + &quot;个客户端连接&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器线程处理类：创建一个类继承Thread并重写run方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // Socket对象</span><br><span class="line">Socket socket = null;</span><br><span class="line">// 构造方法</span><br><span class="line">public ServerThread()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ServerThread(Socket socket)&#123;</span><br><span class="line">    this.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line">// 重写run方法</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    OutputStream os = null;</span><br><span class="line">    InputStream is = null;</span><br><span class="line">    OutputStreamWriter osw = null;</span><br><span class="line">    InputStreamReader isr = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取Socket中的输出流并包装为字符输出流</span><br><span class="line">        os = socket.getOutputStream();</span><br><span class="line">        osw = new OutputStreamWriter(os);</span><br><span class="line">        // 使用字符输出流写入数据</span><br><span class="line">        osw.write(&quot;我是服务器线程类&quot;);</span><br><span class="line">        osw.flush();</span><br><span class="line">        // 获取Socket中的输入流并包装为字符输入流</span><br><span class="line">        is = socket.getInputStream();</span><br><span class="line">        isr = new InputStreamReader(is);</span><br><span class="line">        // 读取输入流中的数据</span><br><span class="line">        int i;</span><br><span class="line">        char[] bytes = new char[8 * 1024];</span><br><span class="line">        while ((i = isr.read(bytes,0,bytes.length)) != -1) &#123;</span><br><span class="line">            System.out.println(new String(bytes,0,i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally&#123;</span><br><span class="line">        // 关闭资源</span><br><span class="line">        try &#123;</span><br><span class="line">            if (osw != null)</span><br><span class="line">                osw.close();</span><br><span class="line">            if (isr != null)</span><br><span class="line">                isr.close();</span><br><span class="line">            if (os != null)</span><br><span class="line">                os.close();</span><br><span class="line">            if (is != null)</span><br><span class="line">                is.close();</span><br><span class="line">            if (socket != null)</span><br><span class="line">                socket.close();</span><br><span class="line">        &#125;catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当每次有客户端连接时都会使用新线程来连接。</p>
<h3 id="基于UDP的网络编程"><a href="#基于UDP的网络编程" class="headerlink" title="基于UDP的网络编程"></a>基于UDP的网络编程</h3><p><strong>UDP协议是无连接、不可靠、无序的。相对来说UDP的传输速度回比较快。UDP是以数据报作为数据传输的载体，使用UDP协议进行数据传输时，首先需要将需要传输的数据封装成数据报，在数据报中指明数据所要到达的Socket（主机地址和端口号），然后在将数据报发送出去。</strong></p>
<h4 id="使用数据报实现UDP编程"><a href="#使用数据报实现UDP编程" class="headerlink" title="使用数据报实现UDP编程"></a>使用数据报实现UDP编程</h4><p><strong>java中有关UDP协议的有DatagramPacket、DatagramSocket两个类，分别表示数据报以及进行端对端通信的类。 </strong></p>
<p>服务器端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // 创建UDPSocket实例，用来发送及接受信息</span><br><span class="line">DatagramSocket ds = new DatagramSocket(8800);</span><br><span class="line">// 接收信息</span><br><span class="line">//创建byte数组用来保存接收到的信息</span><br><span class="line">byte[] bytes = new byte[20 * 1024];</span><br><span class="line">// 创建数据报实例</span><br><span class="line">DatagramPacket dp = new DatagramPacket(bytes, bytes.length);</span><br><span class="line">// 使用UDPSocket的receive方法接受数据，这个方法在收到数据之前会一直阻塞</span><br><span class="line">ds.receive(dp);</span><br><span class="line">System.out.println(new String(bytes));</span><br><span class="line"></span><br><span class="line">// 创建byte数组保存需要发送的数据</span><br><span class="line">byte[] data = &quot;我是服务器端&quot;.getBytes();</span><br><span class="line">// 创建数据报实例并使用UDPSocket的send方法发送数据</span><br><span class="line">DatagramPacket dp2 = new DatagramPacket(data,data.length,dp.getAddress(),dp.getPort());</span><br><span class="line">ds.send(dp2);</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // 创建UDPSocket实例用来发送及接受数据</span><br><span class="line">DatagramSocket ds = new DatagramSocket();</span><br><span class="line"></span><br><span class="line">// 发送数据</span><br><span class="line">// 需要发送的数据</span><br><span class="line">byte[] bytes = &quot;我是客户端&quot;.getBytes();</span><br><span class="line">// 创建数据报并发送</span><br><span class="line">DatagramPacket dp = new DatagramPacket(bytes,bytes.length, InetAddress.getLocalHost(),8800);</span><br><span class="line">ds.send(dp);</span><br><span class="line"></span><br><span class="line">// 接收数据</span><br><span class="line">// 用来保存接收到的数据</span><br><span class="line">byte[] data = new byte[8 * 1024];</span><br><span class="line">// 创建数据报并接受数据</span><br><span class="line">DatagramPacket dp2 = new DatagramPacket(data,data.length,InetAddress.getLocalHost(),8800);</span><br><span class="line">ds.receive(dp2);</span><br><span class="line">System.out.println(new String(data));</span><br></pre></td></tr></table></figure>
<h4 id="使用多线程实现基于UDP的多客户端与服务端连接"><a href="#使用多线程实现基于UDP的多客户端与服务端连接" class="headerlink" title="使用多线程实现基于UDP的多客户端与服务端连接"></a>使用多线程实现基于UDP的多客户端与服务端连接</h4><p>服务器端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建UDPSocket实例，用来发送及接受信息</span><br><span class="line">DatagramSocket ds = new DatagramSocket(8800);</span><br><span class="line">// 接收信息</span><br><span class="line">//创建byte数组用来保存接收到的信息</span><br><span class="line">byte[] bytes = new byte[20 * 1024];</span><br><span class="line">// 创建数据报实例</span><br><span class="line">DatagramPacket dp = new DatagramPacket(bytes, bytes.length);</span><br><span class="line">int count = 0;</span><br><span class="line">while (true)&#123;</span><br><span class="line">    // 使用UDPSocket的receive方法接受数据，这个方法在收到数据之前会一直阻塞</span><br><span class="line">    ds.receive(dp);</span><br><span class="line">    // 创建线程类并准备运行</span><br><span class="line">    ServerThread st = new ServerThread(ds,bytes,dp);</span><br><span class="line">    st.start();</span><br><span class="line">    System.out.println(&quot;当前有&quot; + (++count) + &quot;个客户端已连接&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器线程类代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // 全局变量</span><br><span class="line">DatagramSocket ds = null;</span><br><span class="line">byte[] bytes = null;</span><br><span class="line">DatagramPacket dp = null;</span><br><span class="line">//构造方法</span><br><span class="line">public ServerThread(DatagramSocket ds,byte[] bytes,DatagramPacket dp)&#123;</span><br><span class="line">    this.ds = ds;</span><br><span class="line">    this.bytes = bytes;</span><br><span class="line">    this.dp = dp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重写run方法</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    // 输出接收到的数据</span><br><span class="line">    System.out.println(new String(bytes));</span><br><span class="line">    // 输出客户端IP地址</span><br><span class="line">    System.out.println(dp.getAddress());</span><br><span class="line">    // 创建byte数组保存需要发送的数据</span><br><span class="line">    byte[] data = &quot;我是服务器端&quot;.getBytes();</span><br><span class="line">    // 根据已连接的客户端的IP地址与端口号创建数据报实例并使用UDPSocket的send方法发送数据</span><br><span class="line">    DatagramPacket dp2 = new DatagramPacket(data,data.length,dp.getAddress(),dp.getPort());</span><br><span class="line">    try &#123;</span><br><span class="line">        // 往连接的客户端发送信息</span><br><span class="line">        ds.send(dp2);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="网络编程总结"><a href="#网络编程总结" class="headerlink" title="网络编程总结"></a>网络编程总结</h3><pre><code>1. 多线程的优先级，当服务器需要与多个客户端进行通信，这个时候就需要注意线程的优先级的问题。未设置优先级可能会导致云心速度较慢，这时候可以降低优先级。而设置优先级可以通过setPriority方法。
2. 基于TCOP的Scoket编程时会使用IO流，这时候如果关闭io流，则Scoket也会被关闭，所以一般补不会关闭IO流，直接关闭Scoket即可。
3. 在通信时可以使用ObjectOutputStream与ObjectInputStream来传输对象
</code></pre><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p> <strong>进程与线程:进程是程序或者任务的执行过程，而执行过程是动态性的，只有当程序运行了之后才能称为进程。进程一般持有共享资源如文件、内存以及线程。进程是资源和线程的载体，程序在在运行时是要从内存中读取数据，所以要为进程分配内存。</strong></p>
<p> <strong>线程是系统中最小的执行单元，同一个进程中有多个线程，线程共享进程的资源。线程之间的通信称为线程的交互，交互的方式分为互斥与同步。</strong></p>
<p> <strong>互斥是指某个资源同一时间只能由一个线程使用，当某个线程使用了之后后来的线程需要等待之前的线程使用完。而同步是指多个线程同时完成某个功能。计算机中CPU在同一时间只能运行一条线程。</strong></p>
<h2 id="java中的线程"><a href="#java中的线程" class="headerlink" title="java中的线程"></a>java中的线程</h2><p> <strong>Java中对线程的支持体现在Thread类以及Runnable接口，在Thrad类以及Runnable接口中都有一个run()方法，run方法提供了这个线程需要执行的代码。</strong></p>
<h3 id="线程的常用方法："><a href="#线程的常用方法：" class="headerlink" title="线程的常用方法："></a>线程的常用方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">strat()  是当前线程准备运行，只有使用这个方法，线程才会运行。</span><br><span class="line"></span><br><span class="line">sleep()  使当前线程休眠</span><br><span class="line"></span><br><span class="line">join()   使其他线程等待当前线程终止</span><br><span class="line"></span><br><span class="line">yield()  静态的，使当前运行线程释放处理器资源</span><br><span class="line"></span><br><span class="line">currentThread()   静态的，返回当前运行的线程引用</span><br></pre></td></tr></table></figure>
<h3 id="继承Thread类并重写run-方法"><a href="#继承Thread类并重写run-方法" class="headerlink" title="继承Thread类并重写run()方法"></a>继承Thread类并重写run()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> public void run() &#123;</span><br><span class="line">    // 统计线程运行次数</span><br><span class="line">    int count = 0;</span><br><span class="line">    System.out.println(getName() + &quot;开始执行&quot;);</span><br><span class="line">    // 循环运行线程</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        System.out.println(&quot;第&quot; + (++count) + &quot;次执行&quot; + getName());</span><br><span class="line">        // 当运行次数等于100时退出循环</span><br><span class="line">        if (count == 100)</span><br><span class="line">            break;</span><br><span class="line">        // 没运行10次休眠1秒</span><br><span class="line">        if (count % 10 == 0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(getName() + &quot;结束执行&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承Runnable接口并实现run-方法"><a href="#继承Runnable接口并实现run-方法" class="headerlink" title="继承Runnable接口并实现run()方法"></a>继承Runnable接口并实现run()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public void run() &#123;</span><br><span class="line">    // 统计循环次数</span><br><span class="line">    int count = 0;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot;开始执行&quot;);</span><br><span class="line">    // 循环执行</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        System.out.println(&quot;第&quot; + (++count) + &quot;次执行&quot;);</span><br><span class="line">        // 执行100次退出循环</span><br><span class="line">        if (count == 100)</span><br><span class="line">            break;</span><br><span class="line">        // 执行10次休眠1秒</span><br><span class="line">        if (count % 10 == 0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.currentThread().sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot;结束执行&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行线程"><a href="#运行线程" class="headerlink" title="运行线程"></a>运行线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ThreadTest tt = new ThreadTest();</span><br><span class="line">   Thread t = new Thread(new RunnableTest(),&quot;Runnable&quot;);</span><br><span class="line">   tt.setName(&quot;thread&quot;);</span><br><span class="line">   tt.start();</span><br><span class="line">   t.start();</span><br></pre></td></tr></table></figure>
<p><strong>当运行之后发现两条线程是交替运行的，这是因为计算机中CPU在同一时间只能运行一条线程，而一条线程运行中是可能会被另一条线程抢到CPU的执行权。</strong></p>
<h2 id="利用多线程模拟战争"><a href="#利用多线程模拟战争" class="headerlink" title="利用多线程模拟战争"></a>利用多线程模拟战争</h2><p> 部队类:实现Runnable接口并实现run方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // volatile保证了线程可以正确读取到值被其他线程修改之后的值</span><br><span class="line">volatile boolean keepRunning = true;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    while (keepRunning)&#123;</span><br><span class="line">        for (int i = 1; i &lt;= 5; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;第&quot; + i + &quot;次进攻&quot;);</span><br><span class="line">            // yield方法保证每次攻击之后别人也有出手的机会</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>英雄类：继承Thread类并重写run方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public void run() &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot;开始战斗&quot;);</span><br><span class="line">    for (int i = 1; i &lt;= 10; i++)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;攻击了&quot; + i + &quot;次&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot;结束了战斗&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>舞台类：继承Thread类并重写run方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public void run() &#123;</span><br><span class="line">    // 创建军队线程并让他们准备运行</span><br><span class="line">    ArmyRunnable army = new ArmyRunnable();</span><br><span class="line">    Thread sui1 = new Thread(army,&quot;隋军&quot;);</span><br><span class="line">    Thread free1 = new Thread(army,&quot;起义军&quot;);</span><br><span class="line">    sui1.start();</span><br><span class="line">    free1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 让当前这个线程休眠50毫秒，在执行后边的代码</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(50);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建英雄人物线程</span><br><span class="line">    Thread kpt = new KeyPersonThread(&quot;程咬金&quot;);</span><br><span class="line">    kpt.start();</span><br><span class="line"></span><br><span class="line">    // 结束军队线程的循环</span><br><span class="line">    army.keepRunning = false;</span><br><span class="line"></span><br><span class="line">    // 让当前线程休眠2秒</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*         让主线程等待kpt线程执行完才会执行,而如果把以下代码放到结束军队线程的循环前面，则主线程</span><br><span class="line">      会一直等待军队线程的停止，不会执行结束军队线程的循环代码，军队线程就不会结束循环，就会陷入死循环。</span><br><span class="line">      综上所述，join方法会让在这个线程使用join方法的线程等待调用join方法的线程结束才会继续执行。*/</span><br><span class="line"></span><br><span class="line">    // 让所有线程等待kpt线程结束</span><br><span class="line">    try &#123;</span><br><span class="line">        kpt.join();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="java线程的停止"><a href="#java线程的停止" class="headerlink" title="java线程的停止"></a>java线程的停止</h2><p><strong>停止线程不推荐使用stop方法停止，因为stop方法是直接停止线程，导致不知道线程执行到了哪一步，也不能做清理工作。</strong></p>
<p><strong>确停止线程的方式是为线程设置退出旗标，当在别的线程达到退出的条件时，修改旗标以达到停止线程：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 退出旗标，volatile保证了当前线程可以正确读取到被其他线程修改之后的值</span><br><span class="line">   volatile boolean keepRunning = true;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       while (keepRunning)&#123;</span><br><span class="line">           for (int i = 1; i &lt;= 5; i++)&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + &quot;第&quot; + i + &quot;次进攻&quot;);</span><br><span class="line">               // yield方法保证每次攻击之后别人也有出手的机会</span><br><span class="line">               Thread.yield();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> <strong>interrupt()停止线程方法并不能正确停止线程，因为它是中断当前线程，而不是停止，当线程中断之后，在调用sleep方法或者wait方法时会重置中断状态以及抛出中断异常。这就是sleep或者wait方法需要try Catch的原因，正确的停止线程方法应该是上边提到的设置旗标方法。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">    // 创建线程并准备运行</span><br><span class="line">    Thread thread = new InterruptTest();</span><br><span class="line">    System.out.println(&quot;线程启动&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line">    // 当前线程休眠3秒</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    // 中断线程</span><br><span class="line">    System.out.println(&quot;中断线程&quot;);</span><br><span class="line">  /*  中断线程，当main方法使用sleep方法或者wait方法时线程会继续运行但没有抛出异常，当线程被中断之后</span><br><span class="line">    这个线程调用sleep方法会抛出异常且线程继续运行*/</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;线程结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    // 当这个线程没有中断的时候循环</span><br><span class="line">    while (true)&#123;</span><br><span class="line">        System.out.println(&quot;运行线程...&quot;);</span><br><span class="line">        long time = System.currentTimeMillis();</span><br><span class="line">       while ((System.currentTimeMillis() - time) &lt; 1000)&#123;</span><br><span class="line">           /*减少屏幕输出的空循环，用sleep会抛出异常,当从外层进入到内层循环时，如果运行时间小于1000毫秒</span><br><span class="line">            内层循环会一直循环*/</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上边代码运行结果为线程不能正常停止也不会抛出异常，而当把死循环改为是否中断为条件循环就能正常停止循环，但是在run方法里不能使用sleep方法，负责会抛出异常且不能正常停止线程：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> public void run() &#123;</span><br><span class="line">    // 当这个线程没有中断的时候循环</span><br><span class="line">    while (!this.isInterrupted())&#123;</span><br><span class="line">        System.out.println(&quot;运行线程...&quot;);</span><br><span class="line">        long time = System.currentTimeMillis();</span><br><span class="line">        // 当循环条件为线程是否中断时，这个方法可以达到休眠1秒的作用且不会抛出异常</span><br><span class="line">       while ((System.currentTimeMillis() - time) &lt; 1000)&#123;</span><br><span class="line">           /*减少屏幕输出的空循环，用sleep会抛出异常,当从外层进入到内层循环时，如果运行时间小于1000毫秒</span><br><span class="line">            内层循环会一直循环*/</span><br><span class="line">        &#125;</span><br><span class="line">       // 使用sleep方法会抛出异常，且线程不能正确停止</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>综上所述，正确的停止线程方式为为线程设置循环条件，当要结束线程时，修改循环条件来达到停止线程，而需要注意的是，循环条件要用volatile修饰符修饰，防止当前线程读取不到被其他线程修改之后的值：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 循环条件，volatile修饰符可以保证本线程正确读取到被其他线程修改之后的值</span><br><span class="line">volatile boolean flg = true;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    // 创建线程并准备运行</span><br><span class="line">    Thread thread = new InterruptTest();</span><br><span class="line">    System.out.println(&quot;线程启动&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line">    // 当前线程休眠3秒</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    // 中断线程</span><br><span class="line">    System.out.println(&quot;中断线程&quot;);</span><br><span class="line">    // 把Thread强制转换为InterruptTest类并把循环条件设置为false来停止线程</span><br><span class="line">    ((InterruptTest) thread).flg = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;线程结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    // 根据条件循环</span><br><span class="line">    while (flg)&#123;</span><br><span class="line">        System.out.println(&quot;运行线程...&quot;);</span><br><span class="line">       // 使用sleep方法会抛出异常，且线程不能正确停止</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程的同步与互斥"><a href="#线程的同步与互斥" class="headerlink" title="线程的同步与互斥"></a>线程的同步与互斥</h2><p><strong>互斥：在同一时间只能由一条线程操作数据或临界区。</strong></p>
<p><strong>同步：同步是线程之间的通信机制。也就是说当一条线程操作完之后通过某种方法告诉其他线程当前线程执行完毕。</strong></p>
<p><strong>当我们使用多线程时，有时会导致数据不准确，这是因为争用条件，争用条件：当多个线程同时共享访问同一数据（内存区域）时，每个线程都尝试操作该数据，从而导致数据被破坏，这种现象称为争用条件，通过一个多线程操作数组内的元素的值得例子来看：</strong></p>
<p>数组类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个数组用来让线程执行数组中的元素增加和减少</span><br><span class="line">  private final double[] energyBoxs;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   *</span><br><span class="line">   * @param n   数组大小</span><br><span class="line">   * @param initialEnergy   数组元素的值</span><br><span class="line">   */</span><br><span class="line">  // 构造方法，循环为数组中的每个元素赋值</span><br><span class="line">  public EnergyStytem(int n,double initialEnergy)&#123;</span><br><span class="line">      energyBoxs = new double[n];</span><br><span class="line">      for (int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">          energyBoxs[i] = initialEnergy;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   *</span><br><span class="line">   * @param from  数组中的第from个成员，用来减Amount</span><br><span class="line">   * @param to    数组中的第to个成员，用来加amount</span><br><span class="line">   * @param amount    成员加减的值</span><br><span class="line">   */</span><br><span class="line">  public void transfer(int from,int to, double amount)&#123;</span><br><span class="line">      // 判断第from个成员的值是否大于需要减少的，如果小于，则退出方法</span><br><span class="line">      if (energyBoxs[from] &lt; amount)</span><br><span class="line">          return;</span><br><span class="line">      // 获取当前线程名字</span><br><span class="line">      System.out.println(Thread.currentThread().getName());</span><br><span class="line">      // 使目标元素减少</span><br><span class="line">      energyBoxs[from] -= amount;</span><br><span class="line">      System.out.printf(&quot;从%d转移%10.2f单位能量到%d%n&quot;,from,amount,to);</span><br><span class="line">      //  使目标元素增加</span><br><span class="line">      energyBoxs[to] += amount;</span><br><span class="line">      System.out.printf(&quot;能量总和：%10.2f%n&quot;,getTotalEnergies());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取数组的全部值</span><br><span class="line">  private double getTotalEnergies() &#123;</span><br><span class="line">      double sum = 0;</span><br><span class="line">      for (double d : energyBoxs</span><br><span class="line">           ) &#123;</span><br><span class="line">          sum += d;</span><br><span class="line">      &#125;</span><br><span class="line">      return sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取数组长度</span><br><span class="line">  public int getEnergyBoxesLength()&#123;</span><br><span class="line">      return energyBoxs.length;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>操作数组成语值的类，继承Runnable接口来创建线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 能量系统类</span><br><span class="line">  private EnergyStytem energyStytem;</span><br><span class="line">  // 目标元素</span><br><span class="line">  private int fromBox;</span><br><span class="line">  // 最大转移值</span><br><span class="line">  private double maxAmount;</span><br><span class="line">  // 最大休眠时间</span><br><span class="line">  private final int DELAY = 10;</span><br><span class="line"></span><br><span class="line">  // 构造方法</span><br><span class="line">  public EnergyTransfer(EnergyStytem energyStytem, int fromBox, double maxAmount)&#123;</span><br><span class="line">      this.energyStytem = energyStytem;</span><br><span class="line">      this.fromBox = fromBox;</span><br><span class="line">      this.maxAmount = maxAmount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 能量转移方法</span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      while(true)&#123;</span><br><span class="line">          // 随机获取目标元素的值范围为0-数组最大长度</span><br><span class="line">          int toBox = (int) (energyStytem.getEnergyBoxesLength() * Math.random());</span><br><span class="line">          // 随机获取转移的值，范围为0-maxAmount</span><br><span class="line">          double amount = maxAmount * Math.random();</span><br><span class="line">          // 转移方法</span><br><span class="line">          energyStytem.transfer(fromBox,toBox,amount);</span><br><span class="line">          // 使线程休眠随机毫秒，范围为0-DELAY</span><br><span class="line">          try &#123;</span><br><span class="line">              Thread.sleep((int) (DELAY * Math.random()));</span><br><span class="line">          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>实验类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 数组长度</span><br><span class="line">  public static final int BOX_AMOUNT = 100;</span><br><span class="line">  // 数组元素的值</span><br><span class="line">  public static final double INITIAL_ENERGY = 1000;</span><br><span class="line">  public static void main (String[] args)&#123;</span><br><span class="line">      // 创建能量系统对象</span><br><span class="line">      EnergyStytem es = new EnergyStytem(BOX_AMOUNT,INITIAL_ENERGY);</span><br><span class="line">      // 循环创建能量转移线程并准备运行</span><br><span class="line">      for(int i = 0; i &lt; BOX_AMOUNT; i++)&#123;</span><br><span class="line">          EnergyTransfer tc = new EnergyTransfer(es,i,INITIAL_ENERGY);</span><br><span class="line">          Thread t = new Thread(tc,&quot;转移线程&quot; + i);</span><br><span class="line">          t.start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行上边代码之后会发现在运行过程中数组元素的总值有时会小于100000，而正确的总值应该为数组长度*元素的值也就是100000，这就是因为争用条件。</strong></p>
<h2 id="线程的争用条件"><a href="#线程的争用条件" class="headerlink" title="线程的争用条件"></a>线程的争用条件</h2><p><strong>如何产生条件征用的：在代码运行的在某一时刻，多个线程操作同一目标，但是同一时间CPU只能运行一个线程，线程之间的调度是通过分时&amp;抢占完成的，假设线程A获得了CPU的执行时间，首先从内存区域中取得需要修改的数据到线程的内存中，然后修改。这时线程A执行时间耗尽，执行线程B，线程B同样取得数据并修改，然后写入到原内存区域中，线程B执行完毕之后再执行线程A，这时候线程A的执行结果就会覆盖线程B。</strong></p>
<h2 id="java中线程的互斥与同步"><a href="#java中线程的互斥与同步" class="headerlink" title="java中线程的互斥与同步"></a>java中线程的互斥与同步</h2><p><strong>Java中实现互斥：Java中是通过synchronize关键字实现互斥的，synchronize可以出现在方法之上，也可以出现在方法体之中，而synchronize需要通过传进一个Object对象来实现互斥：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> // 对象锁</span><br><span class="line">private final Object OBJCET_LOCK = new Object();</span><br><span class="line">public void transfer(int from,int to, double amount)&#123;</span><br><span class="line">    synchronized (OBJCET_LOCK)&#123;</span><br><span class="line">        // 判断第from个成员的值是否大于需要减少的，如果小于，则退出方法</span><br><span class="line">        // 退出之后，因为这条线程还可能抢到CPU执行权，然后在获取锁的开销，因此这不是个好的方法</span><br><span class="line">    /*    if (energyBoxs[from] &lt; amount)</span><br><span class="line">            return;*/</span><br><span class="line">    // 当条件不满足时让这个线程等待，而不会继续竞争CPU资源</span><br><span class="line">    while (energyBoxs[from] &lt; amount)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            OBJCET_LOCK.wait();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        // 获取当前线程名字</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        // 使目标元素减少</span><br><span class="line">        energyBoxs[from] -= amount;</span><br><span class="line">        System.out.printf(&quot;从%d转移%10.2f单位能量到%d%n&quot;,from,amount,to);</span><br><span class="line">        //  使目标元素增加</span><br><span class="line">        energyBoxs[to] += amount;</span><br><span class="line">        System.out.printf(&quot;能量总和：%10.2f%n&quot;,getTotalEnergies());</span><br><span class="line">        // 当某个线程执行完毕之后，告诉所有其他线程你可以再次尝试判断能否继续执行</span><br><span class="line">        OBJCET_LOCK.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在以上代码中，通过synchronized关键字实现了线程的互斥操作，通过Object的wait()与notifyAll()方法实现了线程的同步。当线程调用了Objec对象的wait()方法之后，当前线程就会至于Object对象的等待集合（wait set）中</strong></p>
<p><strong>互斥：关键数据在同一时间只能被一个线程访问，Java中由synchronized(intrinsic lock)实现，synchronized相对于给代码加上一把锁，每次只给多个线程之中一个线程钥匙。</strong></p>
<p><strong>同步：当前由于某些条件不具备使当前线程处于等待状态，当其他线程执行完毕可能会使得条件具备，这时候就需要同步来告诉当前线程不需等待了。Java中实现同步通过Objcet对象的wait()/notify()/notifyAll()方法实现</strong></p>
<p><strong>当线程A需要访问共享资源时，首先线程A需要获得锁，获得锁之后进入临界区开始操作，操作过程中如果某种条件不被满足，调用锁对象的wait()方法,在调用wait()方法之后首先释放锁资源，然后进入锁对象的wait set。而这时临界区的所资源被释放，线程B获得锁并进入临界区开始操作，线程B执行完某些操作需要通知wait set中的线程时，会调用notify()方法，而notifyAll()方法会唤醒锁对象的waitSet中的一条线程，使得这条线程有机会重新获得CPU得执行权。而notifyAll()方法会唤醒锁对象的waitSet中的所有线程去争取CPU的执行权</strong></p>
<h2 id="多线程总结"><a href="#多线程总结" class="headerlink" title="多线程总结"></a>多线程总结</h2><ol>
<li><strong>线程的创建可以通过继承Thread类并重写run()方法以及实现Runnable接口及其中的run()方法</strong></li>
<li><strong>volatile关键字可以保证当前线程可以正确获得被其他线程修改的数据</strong></li>
<li><strong>线程之间的争用条件</strong></li>
<li><strong>线程之间的互斥通过synchronized关键字实现</strong></li>
<li><strong>线程的同步通过锁对象的wait()/notify()/notifyAll()方法实现</strong></li>
</ol>
<h1 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h1><p><strong>jdbc的全称为java Data Base Connectivity，它是java应用程序与数据库之间的连接工具，不同的数据库都会实现这个接口，java应用程序就可以通过jdbc连接数据库</strong></p>
<h2 id="jdbc的使用"><a href="#jdbc的使用" class="headerlink" title="jdbc的使用"></a>jdbc的使用</h2><ol>
<li>加载驱动程序，通过Class.forName()方法来加载，需要加载那个驱动程序就把名字当做参数传进去就可以了。加载数据库驱动需要对应的数据库驱动jar包</li>
<li>获得数据库连接，通过DriverManager.gerConnection()方法获得连接，需要把连接地址、用户名及密码当做参数传递进去</li>
<li>创建Statement对象并执行SQL语句</li>
</ol>
<h3 id="使用jdbc连接MySQL数据库"><a href="#使用jdbc连接MySQL数据库" class="headerlink" title="使用jdbc连接MySQL数据库"></a>使用jdbc连接MySQL数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 数据库连接地址常量，字符串含义为jdb连接方式，mysql数据库，连接地址，所需要连接的数据库</span><br><span class="line">   private static final String URL = &quot;jdbc:mysql://127.0.0.1:3306/test&quot;;</span><br><span class="line">   // 用户名常量</span><br><span class="line">   private static final String USER = &quot;root&quot;;</span><br><span class="line">   //密码常量</span><br><span class="line">   private static final String PASSWORD = &quot;root&quot;;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           // 通过反射加载驱动</span><br><span class="line">           Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">           // 通过地址、用户名、密码常量获取数据库连接</span><br><span class="line">           Connection connection = DriverManager.getConnection(URL,USER,PASSWORD);</span><br><span class="line">           // 通过连接获取Statement对象</span><br><span class="line">           Statement statement = connection.createStatement();</span><br><span class="line">           // SQL语句</span><br><span class="line">           String sql = &quot;SELECT * FROM imooc_goddess;&quot;;</span><br><span class="line">           // 通过Statement对象执行sql语句并返回结果集</span><br><span class="line">           ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">           // 遍历结果集,通过结果集的getString()方法获得值，其中参数为想要获取的列名</span><br><span class="line">           while (resultSet.next())&#123;</span><br><span class="line">               System.out.printf(resultSet.getString(&quot;user_name&quot;) + resultSet.getString(&quot;age&quot;));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">           System.out.printf(&quot;找不到这个类&quot;);</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; catch (SQLException e) &#123;</span><br><span class="line">           System.out.printf(&quot;SQL语句错误&quot;);</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用jdbc连接oracle数据库"><a href="#使用jdbc连接oracle数据库" class="headerlink" title="使用jdbc连接oracle数据库"></a>使用jdbc连接oracle数据库</h3><p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 数据库连接对象</span><br><span class="line">private static Connection con;</span><br><span class="line">// 数据库驱动目录</span><br><span class="line">private static final String DRIVER = &quot;oracle.jdbc.OracleDriver&quot;;</span><br><span class="line">// 连接URL，分别是ip地址、端口号及数据库的sid</span><br><span class="line">private static final String URL = &quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;;</span><br><span class="line">// 用户名及密码</span><br><span class="line">private static final String USERNAME = &quot;system&quot;;</span><br><span class="line">private static final String PASSWORD = &quot;root&quot;;</span><br><span class="line">// 静态代码块加载驱动及获取数据库连接</span><br><span class="line">static&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 通过反射加载驱动</span><br><span class="line">        Class.forName(DRIVER);</span><br><span class="line">        // 获取数据库连接</span><br><span class="line">        con = DriverManager.getConnection(URL,USERNAME,PASSWORD);</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(&quot;加载驱动失败&quot;);</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(&quot;连接数据库失败&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 返回连接</span><br><span class="line">public static Connection getConnection()&#123;</span><br><span class="line">    return con;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数据库的sid可以通过在SQLPlus中查询实现:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select instance_name from  V$instance</span><br></pre></td></tr></table></figure>
<h4 id="jdbc调用Oracle数据库的存储过程"><a href="#jdbc调用Oracle数据库的存储过程" class="headerlink" title="jdbc调用Oracle数据库的存储过程"></a>jdbc调用Oracle数据库的存储过程</h4><p>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  // SQL语句，必须带有大括号且使用call关键字</span><br><span class="line">     String sql = &quot;&#123;call IMG_INSERT3(?,?)&#125;&quot;;</span><br><span class="line">// 获取执行存储过程对象</span><br><span class="line">     CallableStatement ps = con.prepareCall(sql);</span><br><span class="line">     // 设置占位符</span><br><span class="line">     ps.setInt(1,file.getId())</span><br><span class="line">     ps.setString(2,file.getFileName());</span><br><span class="line">     // 执行存储过程</span><br><span class="line">     ps.execute();</span><br></pre></td></tr></table></figure></p>
<h2 id="MVC三层架构"><a href="#MVC三层架构" class="headerlink" title="MVC三层架构"></a>MVC三层架构</h2><p><strong>MVC三层架构从上到下分别为View(视图层)、Control(控制层)、Model(模型层)以及最下边的DB(数据库)。模型层包括了对于数据库的映射类以及其中的方法（增删改查等）。控制层用来控制数据流通过程，调用模型层的方法并把结果包装起来交给视图层展示。视图层就是用来展示数据。</strong></p>
<p><strong>MVC架构的流程：视图层用来展示数据及把用户的行为传递给控制层，控制层则根据用户行为更新数据库及模型层，模型层把更新结果重新传递给控制层，控制层在把结果包装起来交给视图层展示</strong></p>
<p><strong>实际开发中，在了解需求之后，根据需求设计数据库，根据数据库设计模型层、根据模型层设计控制层及视图层</strong></p>
<p><strong>模型层包括了与数据库表中的映射-实体类，以及实现实体类方法的Dao文件夹。而通过预编译SQL语句PreparedStatement类可以防止SQL注入。例子：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 获取数据库连接</span><br><span class="line">Connection connection = DBUtil.getConnection();</span><br><span class="line">// SQL语句</span><br><span class="line">String sql = &quot;insert imooc_goddess(user_name,age,birthday) values(?,?,?)&quot;;</span><br><span class="line">// 通过连接获取PreparedStatement对象并把SQL语句传递进去</span><br><span class="line">PreparedStatement statement = connection.prepareStatement(sql);</span><br><span class="line">// 为SQL语句中的占位符设置值</span><br><span class="line">   statement.setString(1,goddess.getUserName());</span><br><span class="line">   statement.setInt(2,goddess.getAge());</span><br><span class="line">   statement.setDate(3,goddess.getBirthday());</span><br><span class="line">// 执行SQL</span><br><span class="line">   statement.execute();</span><br><span class="line">// 获取执行结果，结果为影响的行数</span><br><span class="line">statement.getUpdateCount()</span><br></pre></td></tr></table></figure>
<h3 id="模型层的注意事项："><a href="#模型层的注意事项：" class="headerlink" title="模型层的注意事项："></a>模型层的注意事项：</h3><ol>
<li><p><strong>SQL语句要用空格分开</strong></p>
</li>
<li><p><strong>实体类中Date属性分为Util下的与SQL包下的，有时导错包会导致往数据库中存储Date类型数据出错。因为SQL.Date中的日期只有年月日，没有时分秒，而Util.Date包括年月日时分秒，所有使用Util.Date往数据库中存储Date类型会导致时分秒全部变为0。SQL.Date没办法设置时间，每次插入的都是1970-1-1。所以实体类中的Date应该为Util下的，而PreparedStatement类的setDate中的参数是SQL.Date下的，所以要把Util下的Date转为SQL包下的：</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">new Sql.Date(Util.Date.getTime());</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>PreparedStatement余Statement的区别，Statement对象执行的是静态SQL语句，而PreparedStatement执行的是预编译SQL语句，PreparedStatement可以预防SQL语句注入，更安全，效率也更高</strong></li>
</ol>
<p>创建模型层并创建一个根据多个参数查询的代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 根据传进来的查询字段、查询条件、字段等于的值完成查询</span><br><span class="line">   public Goddess getGoddess(List&lt;Map&lt;String,Object&gt;&gt; parameters)&#123;</span><br><span class="line">       // 拼接SQL</span><br><span class="line">       StringBuilder sql = new StringBuilder(&quot;SELECT * FROM imooc_goddess WHERE 1=1 &quot;);</span><br><span class="line">       if (parameters != null &amp;&amp; parameters.size() &gt; 0)&#123;</span><br><span class="line">           for (Map&lt;String, Object&gt; parameter : parameters) &#123;</span><br><span class="line">               sql.append(&quot;AND &quot; + parameter.get(&quot;name&quot;) + &quot; &quot; + parameter.get(&quot;relation&quot;) + &quot; &quot; + &quot;&apos;&quot; + parameter.get(&quot;value&quot;) + &quot;&apos; &quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 获取数据库连接及根据SQL查询</span><br><span class="line">       Connection con = DBUtil.getConnection();</span><br><span class="line">       Goddess g = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           PreparedStatement st = con.prepareStatement(sql.toString());</span><br><span class="line">           ResultSet rs = st.executeQuery();</span><br><span class="line">           while (rs.next())&#123;</span><br><span class="line">               g = new Goddess();</span><br><span class="line">               g.setUserName(rs.getString(&quot;user_name&quot;));</span><br><span class="line">               g.setId(rs.getInt(&quot;id&quot;));</span><br><span class="line">               g.setAge(rs.getInt(&quot;age&quot;));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (SQLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       return g;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h3><p><strong>控制层是用来接受视图层的操作，在根据视图层的操作调用模型层中的方法修改数据库，模型层在把修改过后的数据通知控制层，控制层在把结果更新给视图层。在MVC架构中控制层起到一个桥梁作用，连接着视图层与模型层。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   // 创建Dao层对象</span><br><span class="line">      GoddessDao gd = new GoddessDao();</span><br><span class="line">      // 创建一个List泛型为Map,每一个Map就是一个查询条件，Map中存放需要查询的字段、条件、字段等于的值</span><br><span class="line">      List&lt;Map&lt;String , Object&gt;&gt; parameters = new ArrayList&lt;&gt;();</span><br><span class="line">      // 添加查询条件，Map中的Value值可以用对象的get方法获取</span><br><span class="line">      Map&lt;String , Object&gt; parameter = new HashMap&lt;&gt;();</span><br><span class="line">      parameter.put(&quot;name&quot;,&quot;birthday&quot;);</span><br><span class="line">      parameter.put(&quot;relation&quot;,&quot;LIKE&quot;);</span><br><span class="line">      parameter.put(&quot;value&quot;,&quot;%12%&quot;);</span><br><span class="line">      Map&lt;String , Object&gt; parameter2 = new HashMap&lt;&gt;();</span><br><span class="line">      parameter2.put(&quot;name&quot;,&quot;mobile&quot;);</span><br><span class="line">      parameter2.put(&quot;relation&quot;,&quot;LIKE&quot;);</span><br><span class="line">      parameter2.put(&quot;value&quot;,&quot;%139%&quot;);</span><br><span class="line">// 往集合中添加对象</span><br><span class="line">      parameters.add(parameter);</span><br><span class="line">      parameters.add(parameter2);</span><br><span class="line">      // 调用Dao层的查询方法</span><br><span class="line">      Goddess g = gd.getGoddess(parameters);</span><br><span class="line">      System.out.println(g);</span><br></pre></td></tr></table></figure>
<h3 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h3><p><strong>视图层是用来展示数据及传递用户操作的</strong></p>
<h2 id="JDBC各种连接方式的对比"><a href="#JDBC各种连接方式的对比" class="headerlink" title="JDBC各种连接方式的对比"></a>JDBC各种连接方式的对比</h2><ol>
<li>JDBC+ODBC桥的方式：需要数据库的ODBC驱动，只适用于微软系统</li>
<li>JDBC+厂商API的形式：厂商API一般使用C编写</li>
<li>JDBC+厂商Database ConnetionServer+DateBase的形式：在java与数据库之间架起了一台专门用于与数据库连接的服务器。</li>
<li>JDBC+数据库的连接方式：这种方式使应用程序与数据库分开，只需要关心内部逻辑的实现，不需要注重数据库连接的具体实现。所以效率较高，推荐使用这种方法</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/13/java中的面向对象/" rel="next" title="java中的面向对象">
                <i class="fa fa-chevron-left"></i> java中的面向对象
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/02/学习时遇到的问题/" rel="prev" title="学习时遇到的问题">
                学习时遇到的问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冰断秋</p>
              <p class="site-description motion-element" itemprop="description">希望你每一天都对得起自己的梦想</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
		
      </section>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=35288859&auto=1&height=66"></iframe>
      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA基础知识"><span class="nav-number">1.</span> <span class="nav-text">JAVA基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理"><span class="nav-number">1.1.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">1.2.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间和日期的处理"><span class="nav-number">1.3.</span> <span class="nav-text">时间和日期的处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math类的常用方法"><span class="nav-number">1.4.</span> <span class="nav-text">Math类的常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合"><span class="nav-number">1.5.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中的进制"><span class="nav-number">1.6.</span> <span class="nav-text">java中的进制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io流"><span class="nav-number">1.7.</span> <span class="nav-text">io流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编码"><span class="nav-number">1.7.1.</span> <span class="nav-text">编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File类"><span class="nav-number">1.7.2.</span> <span class="nav-text">File类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常用方法："><span class="nav-number">1.7.2.1.</span> <span class="nav-text">常用方法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RandomAccessFile类"><span class="nav-number">1.7.3.</span> <span class="nav-text">RandomAccessFile类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节流与字符流"><span class="nav-number">1.7.4.</span> <span class="nav-text">字节流与字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字节流"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">字节流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#字节输入流"><span class="nav-number">1.7.4.1.1.</span> <span class="nav-text">字节输入流</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#InputStream的读方法："><span class="nav-number">1.7.4.1.1.1.</span> <span class="nav-text">InputStream的读方法：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#FileInputStream"><span class="nav-number">1.7.4.1.1.2.</span> <span class="nav-text">FileInputStream</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字节输出流"><span class="nav-number">1.7.4.1.2.</span> <span class="nav-text">字节输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#OutputStream的写方法："><span class="nav-number">1.7.4.1.2.1.</span> <span class="nav-text">OutputStream的写方法：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#FileOutputStream"><span class="nav-number">1.7.4.1.2.2.</span> <span class="nav-text">FileOutputStream</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用字节流实现复制文件："><span class="nav-number">1.7.4.1.3.</span> <span class="nav-text">使用字节流实现复制文件：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据字节流"><span class="nav-number">1.7.4.1.4.</span> <span class="nav-text">数据字节流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#带缓冲区的字节流"><span class="nav-number">1.7.4.1.5.</span> <span class="nav-text">带缓冲区的字节流</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符流"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#字符流的基本实现"><span class="nav-number">1.7.4.2.1.</span> <span class="nav-text">字符流的基本实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileReade与FileWrited"><span class="nav-number">1.7.4.2.2.</span> <span class="nav-text">FileReade与FileWrited</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符流过滤器"><span class="nav-number">1.7.4.2.3.</span> <span class="nav-text">字符流过滤器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#打印流：PrintWriter"><span class="nav-number">1.7.4.2.4.</span> <span class="nav-text">打印流：PrintWriter</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象序列化"><span class="nav-number">1.8.</span> <span class="nav-text">对象序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#序列化基础"><span class="nav-number">1.8.1.</span> <span class="nav-text">序列化基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序列化中子类父类构造方法"><span class="nav-number">1.8.2.</span> <span class="nav-text">序列化中子类父类构造方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java中的XML"><span class="nav-number">2.</span> <span class="nav-text">Java中的XML</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#XML读取"><span class="nav-number">2.1.</span> <span class="nav-text">XML读取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何在Java中保留xml的结构"><span class="nav-number">2.1.1.</span> <span class="nav-text">如何在Java中保留xml的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用的节点类型及方法的返回值"><span class="nav-number">2.1.2.</span> <span class="nav-text">常用的节点类型及方法的返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM方式解析XML文件"><span class="nav-number">2.1.3.</span> <span class="nav-text">DOM方式解析XML文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SAX解析"><span class="nav-number">2.1.4.</span> <span class="nav-text">SAX解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SAX解析XML文件"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">SAX解析XML文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDOM解析"><span class="nav-number">2.1.5.</span> <span class="nav-text">JDOM解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDOM解析的中文乱码问题"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">JDOM解析的中文乱码问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM4J解析"><span class="nav-number">2.1.6.</span> <span class="nav-text">DOM4J解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四种解析方式的分析以及解析速度对比"><span class="nav-number">2.1.7.</span> <span class="nav-text">四种解析方式的分析以及解析速度对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XML写入"><span class="nav-number">2.2.</span> <span class="nav-text">XML写入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM写入"><span class="nav-number">2.2.1.</span> <span class="nav-text">DOM写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SAX生成XML文件"><span class="nav-number">2.2.2.</span> <span class="nav-text">SAX生成XML文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RSS文件"><span class="nav-number">2.2.3.</span> <span class="nav-text">RSS文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM4J生成rss文件"><span class="nav-number">2.2.4.</span> <span class="nav-text">DOM4J生成rss文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDOM生成XML文件"><span class="nav-number">2.2.5.</span> <span class="nav-text">JDOM生成XML文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成方式的对比"><span class="nav-number">2.2.6.</span> <span class="nav-text">生成方式的对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络编程"><span class="nav-number">3.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#网络编程基础"><span class="nav-number">3.1.</span> <span class="nav-text">网络编程基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中的网络通信"><span class="nav-number">3.2.</span> <span class="nav-text">java中的网络通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中网络相关API"><span class="nav-number">3.3.</span> <span class="nav-text">Java中网络相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InetAddress类"><span class="nav-number">3.3.1.</span> <span class="nav-text">InetAddress类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URL类"><span class="nav-number">3.3.2.</span> <span class="nav-text">URL类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于TCP的网络编程"><span class="nav-number">3.3.3.</span> <span class="nav-text">基于TCP的网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过Socket实现TCP编程"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">通过Socket实现TCP编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用多线程实现基于TCP的多客户端与服务器端通信"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">使用多线程实现基于TCP的多客户端与服务器端通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于UDP的网络编程"><span class="nav-number">3.3.4.</span> <span class="nav-text">基于UDP的网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用数据报实现UDP编程"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">使用数据报实现UDP编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用多线程实现基于UDP的多客户端与服务端连接"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">使用多线程实现基于UDP的多客户端与服务端连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络编程总结"><span class="nav-number">3.3.5.</span> <span class="nav-text">网络编程总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程"><span class="nav-number">4.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程与线程"><span class="nav-number">4.1.</span> <span class="nav-text">进程与线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中的线程"><span class="nav-number">4.2.</span> <span class="nav-text">java中的线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的常用方法："><span class="nav-number">4.2.1.</span> <span class="nav-text">线程的常用方法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承Thread类并重写run-方法"><span class="nav-number">4.2.2.</span> <span class="nav-text">继承Thread类并重写run()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承Runnable接口并实现run-方法"><span class="nav-number">4.2.3.</span> <span class="nav-text">继承Runnable接口并实现run()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行线程"><span class="nav-number">4.2.4.</span> <span class="nav-text">运行线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用多线程模拟战争"><span class="nav-number">4.3.</span> <span class="nav-text">利用多线程模拟战争</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java线程的停止"><span class="nav-number">4.4.</span> <span class="nav-text">java线程的停止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的同步与互斥"><span class="nav-number">4.5.</span> <span class="nav-text">线程的同步与互斥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的争用条件"><span class="nav-number">4.6.</span> <span class="nav-text">线程的争用条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中线程的互斥与同步"><span class="nav-number">4.7.</span> <span class="nav-text">java中线程的互斥与同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程总结"><span class="nav-number">4.8.</span> <span class="nav-text">多线程总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jdbc"><span class="nav-number">5.</span> <span class="nav-text">jdbc</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#jdbc的使用"><span class="nav-number">5.1.</span> <span class="nav-text">jdbc的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用jdbc连接MySQL数据库"><span class="nav-number">5.1.1.</span> <span class="nav-text">使用jdbc连接MySQL数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用jdbc连接oracle数据库"><span class="nav-number">5.1.2.</span> <span class="nav-text">使用jdbc连接oracle数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#jdbc调用Oracle数据库的存储过程"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">jdbc调用Oracle数据库的存储过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVC三层架构"><span class="nav-number">5.2.</span> <span class="nav-text">MVC三层架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模型层的注意事项："><span class="nav-number">5.2.1.</span> <span class="nav-text">模型层的注意事项：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制层"><span class="nav-number">5.2.2.</span> <span class="nav-text">控制层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图层"><span class="nav-number">5.2.3.</span> <span class="nav-text">视图层</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDBC各种连接方式的对比"><span class="nav-number">5.3.</span> <span class="nav-text">JDBC各种连接方式的对比</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冰断秋</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
