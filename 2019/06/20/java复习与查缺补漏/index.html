<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="本篇博客记录了java相关的知识点">
<meta name="keywords" content="冰断秋">
<meta property="og:type" content="article">
<meta property="og:title" content="java复习与查缺补漏">
<meta property="og:url" content="http://yoursite.com/2019/06/20/java复习与查缺补漏/index.html">
<meta property="og:site_name" content="但行己路，莫问他人">
<meta property="og:description" content="本篇博客记录了java相关的知识点">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-11-16T17:59:16.181Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java复习与查缺补漏">
<meta name="twitter:description" content="本篇博客记录了java相关的知识点">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/06/20/java复习与查缺补漏/">





  <title>java复习与查缺补漏 | 但行己路，莫问他人</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">但行己路，莫问他人</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/20/java复习与查缺补漏/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="冰断秋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="但行己路，莫问他人">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java复习与查缺补漏</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-20T17:47:40+08:00">
                2019-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>本篇博客记录了java相关的知识点</strong><br><a id="more"></a></p>
<h1 id="JAVA基础知识"><a href="#JAVA基础知识" class="headerlink" title="JAVA基础知识"></a>JAVA基础知识</h1><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li>使用try..catch..finally来捕获异常，使用throw可以在方法体里抛出异常，在声明方法时通过添加throws关键词可以在调用这个方法时必须try..catch或者继续往上抛。可以通过继承Execption类来创建自定义异常类。可以通过printStackTrace来打印异常信息。当运行到抛出异常的代码时，后边的代码就不会再执行。</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>Java中的字符串具有不变形，每次试图改变字符串时都是创建了一个新的字符串对象。如果要频繁修改字符串，应使用StringBuilder类。</li>
<li>String类的常用方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int length()    返回当前字符串的长度。</span><br><span class="line"></span><br><span class="line">int indexOf(char/String ch/str)	返回ch/str在字符串中第一次出现的位置。</span><br><span class="line"></span><br><span class="line">int lastIndexOf(char/String ch/str)   返回ch/str在字符串中最后一次出现的位置。</span><br><span class="line"></span><br><span class="line">String substring(int beginIndex,int endIndex)   获取从begin开始到end结束的字符串</span><br><span class="line"></span><br><span class="line">String substring(int beginIndex)  获取从begin开始到结尾的字符串</span><br><span class="line">1. char charAt(int index)   获取字符串中指定位置的字符</span><br><span class="line"></span><br><span class="line">String[] split(String regex,int limit) 分割字符串</span><br><span class="line"></span><br><span class="line">byte[]  getBytes()	将字符串转换为byte数组</span><br></pre></td></tr></table></figure>
<h2 id="时间和日期的处理"><a href="#时间和日期的处理" class="headerlink" title="时间和日期的处理"></a>时间和日期的处理</h2><ul>
<li>使用Calendar类进行时间和日期的处理：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通过getlnstance()来获取Calendar的实例</span><br><span class="line"></span><br><span class="line">通过 get(Calendar.YEAR/MONTH/MINUTE..)来获取年月日等，创建一个int来接受返回值。</span><br><span class="line">// Calendar常用方法</span><br><span class="line">Date getTime() 获取Calendar的Date对象。</span><br><span class="line"></span><br><span class="line">Long getTimeInMillis()  获取此Calendar的时间值，以毫秒为单位。</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用SimpleDateFormat类初始化日期格式</li>
</ul>
<h2 id="Math类的常用方法"><a href="#Math类的常用方法" class="headerlink" title="Math类的常用方法"></a>Math类的常用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long round()  返回四舍五入后的整数</span><br><span class="line"></span><br><span class="line"> double floor()  返回小于参数的整数</span><br><span class="line"></span><br><span class="line"> double ceil()   返回大于参数的整数</span><br><span class="line"></span><br><span class="line"> double random()  返回[0,1]之间的随机数</span><br></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li><p>泛型集合可以添加泛型的子类对象。</p>
</li>
<li><p>集合可以使用contins(Object o)方法判断当前集合是否有对象o</p>
</li>
<li><p>判断set集合时需要重写equals和hashCode方法</p>
</li>
<li><p>集合中的sort方法判断字符串时会根据首字母依次往后推来判断，从大到小为：0-9,A-Z，a-z</p>
</li>
<li><p>Collection.sort()方法中的形参如果是引用类型，则必须实现Comparable借口</p>
<h2 id="java中的进制"><a href="#java中的进制" class="headerlink" title="java中的进制"></a>java中的进制</h2><p><strong>Java中的进制转换方法都是在integer这个类里边，十进制转其他进制使用toXXXX方法。其他进制转十进制使用parseInt方法</strong></p>
<p>Java中的数据类型所占字节分别是：1个字节是8bit，byte(8bit, -128-127)、short(16bit)、int(32bit)、long(64bit)、单精度(32bit,float)、双精度(64bit,double)、boolean(8bit)、char（Unicode，16bit）</p>
</li>
</ul>
<h2 id="io流"><a href="#io流" class="headerlink" title="io流"></a>io流</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul>
<li>gbk编码中文占用2个字节，英文占用1个，utf-8中文占用3个，英文占用2个，utf-16be中文和英文都是两个字节。当字节序列是某种编码时，解析这个字节序列也必须是这种编码。</li>
</ul>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p><strong>File类只用于表示文件的信息，不能用于访问文件</strong></p>
<h4 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">exists（）  判断调用这个方法的对象存不存在</span><br><span class="line"></span><br><span class="line">mkdir（）   创建文件夹。</span><br><span class="line"></span><br><span class="line">mkdirs（）  创建多个文件夹</span><br><span class="line"></span><br><span class="line">separator  静态属性，设置分割符</span><br><span class="line"></span><br><span class="line">isDirectory（）  判断是否是目录。不是目录或目录不存在返回false</span><br><span class="line"></span><br><span class="line">ifFile（）  是否是一个文件。</span><br><span class="line"></span><br><span class="line">getParent（） 获得父目录。</span><br><span class="line"></span><br><span class="line">list（）  用于列出当前目录下的子目录和文件，不包含子目录下的文件。</span><br></pre></td></tr></table></figure>
<h3 id="RandomAccessFile类"><a href="#RandomAccessFile类" class="headerlink" title="RandomAccessFile类"></a>RandomAccessFile类</h3><p>  <strong>RandomAccessFile类是java提供的读写文件的类，它还支持随机读写文件。</strong>在硬盘上文件是byte储存的，是数据的集合。在调用RandomAccessFile类的构造方法时，除了要给File类，还有指定打开方式，包括”rw”(读写)以及”r”(只读)。在打开文件时，文件指针在开头，point = 0。RandomAccessFile类提供了读和写的方法，分别是write()以及read()，需要注意的是读写方法都是只读写一个字节。文件读写完成以后一定要关闭。raf在读取文件之前一定要把文件指针用seek方法设置到0</p>
<h3 id="字节流与字符流"><a href="#字节流与字符流" class="headerlink" title="字节流与字符流"></a>字节流与字符流</h3><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p><strong>InputStream是字节输入流，用来读取文件的内容。OutputStream是输出流，用来往文件写内容。这两个类是所有字节输入输出流的父类</strong></p>
<h5 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h5><h6 id="InputStream的读方法："><a href="#InputStream的读方法：" class="headerlink" title="InputStream的读方法："></a>InputStream的读方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   read()  返回一个读取到的字节(byte)</span><br><span class="line"></span><br><span class="line">read(byte[] b)  把读取到的字节直接填充到字节数组里</span><br><span class="line"></span><br><span class="line">read(byte[] b，int start,int size)  把读取到的字节从数组的start位置开始放size个</span><br></pre></td></tr></table></figure>
<h6 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h6><p><strong>fileInputStream继承自InputStream。主要实现了对文件的读操其中的read()方法返回的是读取到的有效字节的数量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream in = new FileInputStrea(fileName);</span><br><span class="line">   byte[] buf = new byte[10];</span><br><span class="line">   int bytes = 0;</span><br><span class="line">while((bytes = in.read(buf,0,buf.length)) != -1)&#123;</span><br><span class="line">   	for(int j = 0; j &lt; bytes; j++)&#123;</span><br><span class="line">       	System.out.print(Integer.toHexString(buf[j] &amp; 0xff) + &quot; &quot;);</span><br><span class="line">       	if (i++%10==0)&#123;</span><br><span class="line">           	System.out.println();</span><br><span class="line">       	&#125;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h5><h6 id="OutputStream的写方法："><a href="#OutputStream的写方法：" class="headerlink" title="OutputStream的写方法："></a>OutputStream的写方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">write(int b) 把b的低八位写入到流</span><br><span class="line"></span><br><span class="line">write(byte[] bt)  把字节数组bt写入到流</span><br><span class="line"></span><br><span class="line">write(byte[] be, int start, int size)  把字节数组be从start开始写size个到流</span><br></pre></td></tr></table></figure>
<h6 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h6><p><strong>实现了对文件的写操作。当创建FileOutputStream的对象时，如果文件不存在则创建，存在则删除掉重新创建。如果不想重新创建，则需要把append设为true。当调用write方法时只写入低八位。</strong></p>
<h5 id="使用字节流实现复制文件："><a href="#使用字节流实现复制文件：" class="headerlink" title="使用字节流实现复制文件："></a>使用字节流实现复制文件：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void copyFile(File srcFile, File destFile)throws IOException&#123;</span><br><span class="line">       if (!srcFile.exists())&#123;</span><br><span class="line">           throw new IllegalArgumentException(srcFile + &quot;不存在&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (!srcFile.isFile())&#123;</span><br><span class="line">           throw new IllegalArgumentException(srcFile + &quot;不是一个有效文件&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       FileInputStream in = new FileInputStream(srcFile);</span><br><span class="line">       FileOutputStream out = new FileOutputStream(destFile);</span><br><span class="line">       byte[] buf = new byte[20 * 1024];</span><br><span class="line">       int i;</span><br><span class="line">       while ((i = in.read(buf,0,buf.length)) != -1)&#123;</span><br><span class="line">           out.write(buf,0,i);</span><br><span class="line">           out.flush();</span><br><span class="line">       &#125;</span><br><span class="line">       in.close();</span><br><span class="line">       out.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>字节流读写方法中每次读取或写入一个数组的方法读取或写入速度最快。</strong></p>
<h5 id="数据字节流"><a href="#数据字节流" class="headerlink" title="数据字节流"></a>数据字节流</h5><p> <strong>数据字节流DateInputStream与DateOutputStream，dis与dos是对普通流的一个扩展，用于方便的读写数据。使用了装饰模式，调用dis与dos的构造方法时需要对应的输入输出流。dis&amp;dos相比原本的输入输出流可以直接写入或读取基本数据类型。不需要自己在手写实现。</strong></p>
<h5 id="带缓冲区的字节流"><a href="#带缓冲区的字节流" class="headerlink" title="带缓冲区的字节流"></a>带缓冲区的字节流</h5><p> <strong>带缓冲区的字节流BufferedInputStream&amp;BufferedOutputStream，bis&amp;bos相比于原本的io流与数据io流提供了带缓冲区的io流，原本的io流当调用写入或读取方法时，直接操作内存，而带缓冲区的io流则会吧数据存入缓冲区，当缓冲区满或者调用flush()时在写入内存。所以当写入数据较少时如果不调用flush()方法就不会写入。</strong></p>
<p> 创建一个带缓冲区的字节流：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));</span><br><span class="line">   BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile,true));</span><br><span class="line">   int i = 0;</span><br><span class="line">   while((i = bis.read()) != -1)&#123;</span><br><span class="line">       bos.write(i);</span><br><span class="line">       bos.flush();</span><br><span class="line">   &#125;</span><br><span class="line">   bis.close();</span><br><span class="line">   bos.close();</span><br></pre></td></tr></table></figure></p>
<p>缓冲读取相对于批量读取减少了操作内存的次数。可以用System类的currentTimeMills方法来获取当前毫秒数，在方法开始前获取一次，方法结束后在获取一次，获取后的减去获取前的就是方法运行所需的毫秒数。</p>
<h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p><strong>字符流是用来处理文本文件的io流，java的文本(char) 是16位无符号整数，是字符的unicode编码。而文件是byte byte byte的数据序列。文本文件是文本(char)按照某种编码序列化位byte储存的文件。字符流一次处理一个字符(char),底层仍然是字节流。</strong></p>
<h5 id="字符流的基本实现"><a href="#字符流的基本实现" class="headerlink" title="字符流的基本实现"></a>字符流的基本实现</h5><p> <strong>InputStreamRader与OutputStreamWriter其中Input完成byte解析为char，output完成char解析为byte。当调用InputStreamReader的构造方法时可以指定编码格式。</strong></p>
<p>应用InputStreamRader读取文件内容并打印到控制台：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = new InputStreamReader(new FileInputStream(new File(</span><br><span class="line">          &quot;E:\\java\\imooc\\Day01\\imooc.iml&quot;)));</span><br><span class="line">  int i = 0;</span><br><span class="line">  char[] buf = new char[8 * 1024];</span><br><span class="line">  while((i = isr.read(buf,0,buf.length)) != -1)&#123;</span><br><span class="line">      System.out.println(new String(buf,0,i));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="FileReade与FileWrited"><a href="#FileReade与FileWrited" class="headerlink" title="FileReade与FileWrited"></a>FileReade与FileWrited</h5><p> <strong>fr与fw是针对文件的字符流读写类，但是要注意的是在创建这两个类的对象时不能指定编码格式，默认使用项目的编码。所有有时候会导致乱码问题。</strong></p>
<h5 id="字符流过滤器"><a href="#字符流过滤器" class="headerlink" title="字符流过滤器"></a>字符流过滤器</h5><p> <strong>bufferReader与BufferWrite是对InputStreamRader与OutputStreamWriter的增强。过滤器相对于原来的字符流提供了缓冲区，需要注意的是读的时候并不能识别换行，在写文件的时候需要调用newLine方法来换行。</strong></p>
<h5 id="打印流：PrintWriter"><a href="#打印流：PrintWriter" class="headerlink" title="打印流：PrintWriter"></a>打印流：PrintWriter</h5><p>应用打印流读取文件并输出到控制到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;E:\\java\\imooc\\Day01\\imooc.iml&quot;));</span><br><span class="line"></span><br><span class="line">  PrintWriter pw = new PrintWriter(&quot;demo/imooc.txt&quot;);</span><br><span class="line">  String line;</span><br><span class="line">  while((line = br.readLine()) != null)&#123;</span><br><span class="line">      System.out.println(line);</span><br><span class="line">      pw.println(line);</span><br><span class="line">      pw.flush();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  br.close();</span><br><span class="line">  pw.close();</span><br></pre></td></tr></table></figure></p>
<h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><h3 id="序列化基础"><a href="#序列化基础" class="headerlink" title="序列化基础"></a>序列化基础</h3><p> <strong>对象序列化就是把一个Object转换成byte序列储存，反之就叫做反序列化。Java中实现序列化的io流是ObjectOutputStream与ObjectInputStream类它们是字节的过滤流，一个对象要进行序列化，必须要实现序列化接口。对象序列化就是把对象储存起来。</strong></p>
<p> 对象序列化的代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"> File f = new File(&quot;demo/student.txt&quot;);</span><br><span class="line">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(f));</span><br><span class="line"> Student sd = new Student(1,&quot;a&quot;,18);</span><br><span class="line"> oos.writeObject(sd);</span><br><span class="line"> oos.close();</span><br><span class="line"> ObjectInputStream ois = new ObjectInputStream(new FileInputStream(f));</span><br><span class="line"> Object o = ois.readObject();</span><br><span class="line"> if (o instanceof Student)&#123;</span><br><span class="line">     Student stu = (Student) o;</span><br><span class="line">     System.out.println(stu);</span><br><span class="line"> &#125;</span><br><span class="line"> ois.close();</span><br></pre></td></tr></table></figure>
<p><strong>在对象序列化时用transient修饰的属性不会进行jvm默认的序列化，但是可以自己完成属性的序列化,transient一般用来提高序列化性能。</strong>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private transient int stuAge;</span><br><span class="line">private void writeObject(java.io.ObjectOutputStream s)throws java.io.IOException&#123;</span><br><span class="line">      s.defaultWriteObject();</span><br><span class="line">      s.writeInt(stuAge);</span><br><span class="line">   &#125;</span><br><span class="line">   private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">          throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">      s.defaultReadObject();</span><br><span class="line">      stuAge = s.readInt();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是自定义对象序列化的读写时，先写哪个参数就会先读哪个参数。</strong></p>
<h3 id="序列化中子类父类构造方法"><a href="#序列化中子类父类构造方法" class="headerlink" title="序列化中子类父类构造方法"></a>序列化中子类父类构造方法</h3><p> 当一个类实现了序列化接口，它的子类都可以实现序列化，当一个子类进行序列化时，会递归调用父类的构造方法，当一个子类被反序列化时，会递归调用父类没有实现序列化接口的构造方法。原因是如果父类实现了序列化接口，在序列化时会把父类的构造方法也序列化，反之则会在反序列化时调用父类的构造方法。</p>
<h1 id="Java中的XML"><a href="#Java中的XML" class="headerlink" title="Java中的XML"></a>Java中的XML</h1><p> <strong>xml文件常用来数据存储于传输。xml文件的存储是以树形结构存储的，每个节点可以有属性，节点名称区分大小写。xml文件要在文件首句声明，声明形式为：<br>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</strong></p>
<p>xml应用于不同应用、软件、平台之间的通信，Java中可以使用DOM、SAX、DOM4J、JDOM解析4中方法，前两种是Java官方提供的方式，DOM4J及JDOM需要额外的下载Jar包并添加到项目中。</p>
<h2 id="XML读取"><a href="#XML读取" class="headerlink" title="XML读取"></a>XML读取</h2><h3 id="如何在Java中保留xml的结构"><a href="#如何在Java中保留xml的结构" class="headerlink" title="如何在Java中保留xml的结构"></a>如何在Java中保留xml的结构</h3><p> 创建一个类，类的属性与xml的节点属性相对应，然后在解析的时候创建这个类的实例并把解析出来的节点存到类里。</p>
<h3 id="常用的节点类型及方法的返回值"><a href="#常用的节点类型及方法的返回值" class="headerlink" title="常用的节点类型及方法的返回值"></a>常用的节点类型及方法的返回值</h3><table>
<thead>
<tr>
<th>节点类型</th>
<th>nodeName返回值</th>
<th>nodeValue返回值</th>
<th>NodeType</th>
<th>NamedConstant </th>
</tr>
</thead>
<tbody>
<tr>
<td>Element</td>
<td>ElementName</td>
<td>null</td>
<td>1</td>
<td>ELEMENT_NODE</td>
</tr>
<tr>
<td>Attr</td>
<td>属性名称</td>
<td>属性值</td>
<td>2</td>
<td>ATTR_NODE</td>
</tr>
<tr>
<td>Text</td>
<td>#text</td>
<td>节点内容</td>
<td>3</td>
<td>TEXT_NODE</td>
</tr>
</tbody>
</table>
<h3 id="DOM方式解析XML文件"><a href="#DOM方式解析XML文件" class="headerlink" title="DOM方式解析XML文件"></a>DOM方式解析XML文件</h3><ol>
<li>首先取得xml文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//通过DocumentBuilderFactory的静态方法创建一个DocumentBuilderFactory对象</span><br><span class="line">   DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">   //通过DocumentBuilderFactory对象创建一个DocumentBuilder对象</span><br><span class="line">   DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">   //通过DocumentBuilder对象解析xml文件</span><br><span class="line">   Document d = db.parse(&quot;demo/books.xml&quot;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>以book节点为例，取得book节点的所有属性并遍历：</li>
</ol>
<p>在不知道节点的属性个数及名字的情况下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//通过标签名字获取标签集合</span><br><span class="line">   NodeList books = d.getElementsByTagName(&quot;book&quot;);</span><br><span class="line">      //遍历标签集合</span><br><span class="line">      for (int i = 0; i &lt; books.getLength(); i++)&#123;</span><br><span class="line">          //获取标签</span><br><span class="line">          Node n = books.item(i);</span><br><span class="line">          //获取标签的所有属性</span><br><span class="line">          NamedNodeMap nnm =  n.getAttributes();</span><br><span class="line">          //遍历标签的属性并输出属性名和属性值</span><br><span class="line">          for(int j = 0; j &lt; nnm.getLength(); j++)&#123;</span><br><span class="line">              System.out.println(&quot;名字&quot; + nnm.item(j).getNodeName() + &quot;属性&quot; + nnm.item(j).getNodeValue() );</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>  在知道属性名字的情况下，可以通过属性名字获取属性值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//通过标签名字获取标签集合</span><br><span class="line">   NodeList books = d.getElementsByTagName(&quot;book&quot;);</span><br><span class="line">      //遍历标签集合</span><br><span class="line">      for (int i = 0; i &lt; books.getLength(); i++)&#123;</span><br><span class="line">	  //如果标签集合中的成员不能转换为Element则抛出异常</span><br><span class="line">         if (!(books.item(i) instanceof Element))&#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;111&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         //把标签集合中的成员转换为Element</span><br><span class="line">          Element book =(Element) books.item(i);</span><br><span class="line">         //通过Element的getAttribute方法获得属性名为ID的属性值</span><br><span class="line">          String val = book.getAttribute(&quot;name&quot;);</span><br><span class="line">          System.out.println(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>解析子节点</li>
</ol>
<p>以book节点为例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> NodeList books = d.getElementsByTagName(&quot;book&quot;);</span><br><span class="line">    //遍历节点集合</span><br><span class="line">    for (int i = 0; i &lt; books.getLength(); i++)&#123;</span><br><span class="line">         //获取第i个book节点</span><br><span class="line">         Node book = books.item(i);</span><br><span class="line">         //获取book节点的子节点</span><br><span class="line">         NodeList childs = book.getChildNodes();</span><br><span class="line">         //遍历子节点</span><br><span class="line">         for(int k = 0; k &lt; childs.getLength(); k++)&#123;</span><br><span class="line">             //取得第k个子节点</span><br><span class="line">             Node child = childs.item(k);</span><br><span class="line">             //判断子节点是否为Element类型，如果是则输出节点名字与节点文本</span><br><span class="line">             if (child.getNodeType() == Node.ELEMENT_NODE)&#123;</span><br><span class="line">                 //输出节点名字</span><br><span class="line">                 System.out.print(child.getNodeName());</span><br><span class="line">                 //输出节点文本</span><br><span class="line">                 System.out.println(child.getFirstChild().getNodeValue());</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是直接使用getNodeValue()方法，获取不到文本值，这是因为把book的文本内容当做了一个子节点，所有要在使用getFirstChild()方法获取book的第一个子节点，在获取这个子节点的值。当book方法有多个子节点且第一个子节点也是Element，会获取不到文本值。</strong></p>
<p>还有另一种方法获取文本：这个方法时获取book节点的子节点中的所有文本值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(child.getTextContent());</span><br></pre></td></tr></table></figure>
<p><strong>两种方法的区别是前者是获取子节点的value值，后者是获取子节点中的所有文本值。</strong></p>
<h3 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h3><p> <strong>DOM解析与SAX解析的不同，DOM解析会把整个XML文件加载到内存中，然后逐个解析，SAX解析是通过Handler类按顺序逐个解析节点。SAX解析在碰到开始标签是会调用startElement方法，结束标签会调用endElement方法</strong></p>
<p> <strong>在创建SAX解析器对象后调用parse()方法发现需要创建一个DefaultHandler的对象，DefaultHandler类中的startElement方法是当解析到开始标签要做什么，而SAXParser的parse方法是解析xml文件的</strong></p>
<h4 id="SAX解析XML文件"><a href="#SAX解析XML文件" class="headerlink" title="SAX解析XML文件"></a>SAX解析XML文件</h4><ol>
<li><p>创建SAX解析的实例并获取XML文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SAXParserFactory saxFactory = SAXParserFactory.newInstance();</span><br><span class="line"></span><br><span class="line">   SAXParser parser = saxFactory.newSAXParser();</span><br><span class="line">   DefaultHandler dh = new SAXParserHandler();</span><br><span class="line">   parser.parse(&quot;demo/books.xml&quot;,dh);</span><br></pre></td></tr></table></figure>
</li>
<li><p>SAX解析获得属性值以及属性名：</p>
<p><strong>当已知标签属性的名字及个数时,可以直接使用getValue方法获得属性的值。</strong></p>
</li>
</ol>
<p>当不知道属性名及个数时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> for (int i = 0; i &lt; attributes.getLength(); i++)&#123;</span><br><span class="line">    //获得属性值</span><br><span class="line">    System.out.println(attributes.getValue(i));</span><br><span class="line">    //获得属性值</span><br><span class="line">    System.out.println(attributes.getQName(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>SAX解析获得节点名及节点值并不输出空格与换行：</p>
<p><strong>每当遇到一个新的开始节点，qName就是当前节点名。而character就是当前的节点值。需要注意的是空格与换行也会被解析为节点，所以空格与换行也会被输出。</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String str = new String(ch,start,length);</span><br><span class="line">if (!(&quot;&quot;.equals(str.trim())))&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SAX解析中defaultHandler的方法调用顺序，首先是startDocument、startEmelent、characters、endEmelent、endDocument，其中startEmelent获取节点名、节点属性。characters获取节点内容。</strong></p>
<h3 id="JDOM解析"><a href="#JDOM解析" class="headerlink" title="JDOM解析"></a>JDOM解析</h3><p><strong>JDOM不是官方提供的解析方式，所以要导入额外的jar包。+ 项目中jar包需要创建一个lib文件夹用来存放。</strong></p>
<ol>
<li>JDOM解析Xml文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SAXBuilder sax = new SAXBuilder();</span><br><span class="line">   Document document = sax.build(new FileInputStream(&quot;demo/books.xml&quot;));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>JDOM获取节点属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> //获取根节点</span><br><span class="line">Element rootElement = document.getRootElement();</span><br><span class="line">//通过根节点获取子节点</span><br><span class="line">List&lt;Element&gt; childred = rootElement.getChildren();</span><br><span class="line">//获取子节点的属性名以及属性值</span><br><span class="line">for(Element e : childred)&#123;</span><br><span class="line">    List&lt;Attribute&gt; attrib = e.getAttributes();</span><br><span class="line">    for (Attribute a : attrib</span><br><span class="line">         ) &#123;</span><br><span class="line">        //获取属性名</span><br><span class="line">        System.out.println(a.getName());</span><br><span class="line">        //获取属性值</span><br><span class="line">        System.out.println(a.getValue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>JDOM中的getValue方法不会获取空格与换行,在知道属性名字获取属性值时可以通过getAttributeValue方法传入属性名获取属性值</strong></p>
<ol start="3">
<li>JDOM获取节点名字与节点值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//获取子节点的子节点</span><br><span class="line">          List&lt;Element&gt; elements = e.getChildren();</span><br><span class="line">          //遍历子节点集合</span><br><span class="line">          for (Element ele : elements</span><br><span class="line">               ) &#123;</span><br><span class="line">              //获取子节点的名字</span><br><span class="line">              System.out.println(ele.getName());</span><br><span class="line">              //获取子节点的内容</span><br><span class="line">              System.out.println(ele.getValue());</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<h4 id="JDOM解析的中文乱码问题"><a href="#JDOM解析的中文乱码问题" class="headerlink" title="JDOM解析的中文乱码问题"></a>JDOM解析的中文乱码问题</h4><p> <strong>可能是xml文件的编码格式声明为不支持中文的编码，或者是解析时用不支持中文的编码来解析。xml文件中是encodeing属性声明编码格式的，而代码中可能是因为IO流解析时的编码问题。</strong></p>
<h3 id="DOM4J解析"><a href="#DOM4J解析" class="headerlink" title="DOM4J解析"></a>DOM4J解析</h3><ol>
<li>解析XML文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SAXReader sr = new SAXReader();</span><br><span class="line">Document document = sr.read(new FileInputStream(&quot;demo/books.xml&quot;));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>解析节点属性以及子节点</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">//获取根节点</span><br><span class="line">Element rootElement = document.getRootElement();</span><br><span class="line">//通过根节点获取子节点集合</span><br><span class="line">List&lt;Element&gt; books = rootElement.elements();</span><br><span class="line">//通过迭代器迭代子节点</span><br><span class="line">Iterator&lt;Element&gt; it = books.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">    Element element = it.next();</span><br><span class="line">    //获取子节点的属性集合</span><br><span class="line">    List&lt;Attribute&gt; attributes =  element.attributes();</span><br><span class="line">    for (Attribute a : attributes</span><br><span class="line">         ) &#123;</span><br><span class="line">        //属性名</span><br><span class="line">        System.out.println(a.getName());</span><br><span class="line">        //属性值</span><br><span class="line">        System.out.println(a.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    //获取子节点的子节点集合</span><br><span class="line">    List&lt;Element&gt; elements =  element.elements();</span><br><span class="line">    //遍历子节点</span><br><span class="line">    for (Element ele : elements</span><br><span class="line">         ) &#123;</span><br><span class="line">        //获取当前子节点的节点名</span><br><span class="line">        System.out.println(ele.getName());</span><br><span class="line">        //获取当前子节点的节点值</span><br><span class="line">        System.out.println(ele.getStringValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四种解析方式的分析以及解析速度对比"><a href="#四种解析方式的分析以及解析速度对比" class="headerlink" title="四种解析方式的分析以及解析速度对比"></a>四种解析方式的分析以及解析速度对比</h3><p><strong>java官方解析方式：DOM以及SAX，其中DOM是与语言无关的解析方式，而SAX是Java所独有的，JDOM以及DOM4J就是根据SAX扩展而来的，它们是第三方提供的解析方式。其中DOM4J相对JDOM来说，各方面都会好一点。</strong></p>
<p><strong>DOM解析：DOM解析会一次性的把XML文件写进内存中，并且形成一个DOM树，因为DOM会一次加载整个xml文件，所以当xml文件过大时，加载速度会过慢。并且对计算机运行内存也有要求。</strong></p>
<p><strong>SAX解析：SAX解析时一种基于事件的解析方式，所谓的基于事件的解析方式就是逐条语句解析的，然后判断是否符合某一个条件，如果是，则执行符合条件的方法。</strong></p>
<p><strong>通过观察四种解析速度的对比，sax解析速度最快，dom和jdom差不多，dom4j速度最慢。</strong></p>
<h2 id="XML写入"><a href="#XML写入" class="headerlink" title="XML写入"></a>XML写入</h2><p><strong>DOM与SAX是官方提供的XML文件的写入方法，会生成一个xml文件。DOM4J与JDOM是非官方提供的，会生成一个rss文件。</strong></p>
<h3 id="DOM写入"><a href="#DOM写入" class="headerlink" title="DOM写入"></a>DOM写入</h3><ol>
<li>生成DOM树</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> //创建DOM树</span><br><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">Document d = db.newDocument();</span><br><span class="line">//为DOM树添加节点</span><br><span class="line">Element book = d.createElement(&quot;book&quot;);</span><br><span class="line">Element rootNode = d.createElement(&quot;bookStore&quot;);</span><br><span class="line">d.appendChild(rootNode);</span><br><span class="line">rootNode.appendChild(book);</span><br><span class="line">//为DOM树中的book标签添加属性</span><br><span class="line">book.setAttribute(&quot;id&quot;,&quot;1&quot;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建xml文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">       // 生成xml文件</span><br><span class="line">      TransformerFactory tff = TransformerFactory.newInstance();</span><br><span class="line">      Transformer tf = tff.newTransformer();</span><br><span class="line">      // 设置是否换行</span><br><span class="line">      tf.setOutputProperty(OutputKeys.INDENT,&quot;yes&quot;);</span><br><span class="line">//生成文件</span><br><span class="line">      tf.transform(new DOMSource(d),new StreamResult(new File(&quot;demo/books1.xml&quot;)));</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>生成节点间的文本</li>
</ol>
<p><strong>需要注意的是Element类型的节点使用setNodeValue方法生成的节点间的文本为空，需要使用setTextContent方法。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // 生成节点间文本</span><br><span class="line">name.setTextContent(&quot;小王子&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="SAX生成XML文件"><a href="#SAX生成XML文件" class="headerlink" title="SAX生成XML文件"></a>SAX生成XML文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> //生成xml文件</span><br><span class="line">SAXTransformerFactory sff = (SAXTransformerFactory) SAXTransformerFactory.newInstance();</span><br><span class="line">// 获得TransformerHandler对象</span><br><span class="line">TransformerHandler tfh = sff.newTransformerHandler();</span><br><span class="line">//通过TransformerHandler对象的Transformer设置xml文件</span><br><span class="line">Transformer tf = tfh.getTransformer();</span><br><span class="line">tf.setOutputProperty(OutputKeys.INDENT,&quot;yes&quot;);</span><br><span class="line">tf.setOutputProperty(OutputKeys.ENCODING,&quot;GBK&quot;);</span><br><span class="line">// 创建一个结果流并关联到获得TransformerHandler对象里</span><br><span class="line">Result result = new StreamResult(new FileOutputStream(&quot;demo/books2.xml&quot;));</span><br><span class="line">tfh.setResult(result);</span><br><span class="line">// 生成节点及节点属性</span><br><span class="line">tfh.startDocument();</span><br><span class="line">// 属性</span><br><span class="line">AttributesImpl atts = new AttributesImpl();</span><br><span class="line">// 生成根节点并把属性解析进去</span><br><span class="line">tfh.startElement(&quot;&quot;,&quot;&quot;,&quot;bookStroe&quot;, atts);</span><br><span class="line">// 清除atts的值</span><br><span class="line">atts.clear();</span><br><span class="line">// 添加属性</span><br><span class="line">atts.addAttribute(&quot;&quot;,&quot;&quot;,&quot;id&quot;,&quot;&quot;,&quot;1&quot;);</span><br><span class="line">//在根节点下增加子节点，并把刚刚添加的属性解析进去</span><br><span class="line">tfh.startElement(&quot;&quot;,&quot;&quot;,&quot;book&quot;,atts);</span><br><span class="line">//清除 atts</span><br><span class="line">atts.clear();</span><br><span class="line">// 在子节点下增加字节点</span><br><span class="line">tfh.startElement(&quot;&quot;,&quot;&quot;,&quot;name&quot;,atts);</span><br><span class="line">// 为name子节点增加文本内容</span><br><span class="line">tfh.characters(&quot;小王子&quot;.toCharArray(),0,&quot;小王子&quot;.toCharArray().length);</span><br><span class="line">// 为每一个开始标签增加结束标签</span><br><span class="line">tfh.endElement(&quot;&quot;,&quot;&quot;,&quot;name&quot;);</span><br><span class="line">tfh.endElement(&quot;&quot;,&quot;&quot;,&quot;book&quot;);</span><br><span class="line">tfh.endElement(&quot;&quot;,&quot;&quot;,&quot;bookStroe&quot;);</span><br><span class="line">tfh.endDocument();</span><br></pre></td></tr></table></figure>
<p> <strong>需要注意的是，如果把设置xml文件放在关联结果流会导致设置xml文件失效。而把关联结果流放到生成节点与属性之后会有异常。</strong></p>
<h3 id="RSS文件"><a href="#RSS文件" class="headerlink" title="RSS文件"></a>RSS文件</h3><p>JDOM和DOM4J都会生成一个RSS文件，那么什么是RSS文件？RSS本质上还是xml文件，rss文件相对于xml文件会多一个rss根标签</p>
<h3 id="DOM4J生成rss文件"><a href="#DOM4J生成rss文件" class="headerlink" title="DOM4J生成rss文件"></a>DOM4J生成rss文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> //  创建document对象，代表xml文件</span><br><span class="line">Document document = DocumentHelper.createDocument();</span><br><span class="line">// 设置xml文件使自动换行且自动缩进</span><br><span class="line">OutputFormat format = OutputFormat.createPrettyPrint();</span><br><span class="line">// 添加节点并添加属性</span><br><span class="line">Element rss = document.addElement(&quot;rss&quot;).addAttribute(&quot;version&quot;,&quot;2.0&quot;);</span><br><span class="line">Element books = rss.addElement(&quot;bookstore&quot;);</span><br><span class="line">books.addElement(&quot;book&quot;).addAttribute(&quot;id&quot;,&quot;1&quot;).addElement(&quot;name&quot;).addText(&quot;小王子&quot;);</span><br><span class="line">// 生成xml文件</span><br><span class="line">XMLWriter writer = new XMLWriter(new FileOutputStream(new File(&quot;demo/dom4j.xml&quot;)),format);</span><br><span class="line">writer.write(document);</span><br></pre></td></tr></table></figure>
<p>生成RSS文件时处理转移字符：</p>
<p><strong>DOM4J对于需要转义的字符，已经自动处理了，而如果不想自动处理，则可以调用xml输出流的setEscapeTest方法设置为false</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">XMLwrite write = new XMLWrite();</span><br><span class="line">write.setEscapeTest(false);</span><br></pre></td></tr></table></figure>
<h3 id="JDOM生成XML文件"><a href="#JDOM生成XML文件" class="headerlink" title="JDOM生成XML文件"></a>JDOM生成XML文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // 创建DOM树并增加节点与属性</span><br><span class="line">Document document = new Document();</span><br><span class="line">Element rss = new Element(&quot;rss&quot;).setAttribute(&quot;version&quot;,&quot;2.0&quot;);</span><br><span class="line">Element books = new Element(&quot;bookstore&quot;);</span><br><span class="line">Element book = new Element(&quot;book&quot;).setAttribute(&quot;id&quot;,&quot;1&quot;);</span><br><span class="line">Element name = new Element(&quot;name&quot;);</span><br><span class="line">document.addContent(rss);</span><br><span class="line">rss.addContent(books);</span><br><span class="line">books.addContent(book);</span><br><span class="line">book.addContent(name);</span><br><span class="line">name.addContent(&quot;小王子&lt;&quot;);</span><br><span class="line">// 设置xml文件的编码格式与换行缩进</span><br><span class="line">Format format = Format.getPrettyFormat();</span><br><span class="line">format.setEncoding(&quot;utf-8&quot;);</span><br><span class="line">//  使xml文件不进行自动转义</span><br><span class="line">XMLOutputter output = new XMLOutputter(format)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String escapeElementEntities(String str) &#123;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 生成xml文件</span><br><span class="line">output.output(document,new FileOutputStream(new File(&quot;demo/jdom2.xml&quot;)));</span><br></pre></td></tr></table></figure>
<h3 id="生成方式的对比"><a href="#生成方式的对比" class="headerlink" title="生成方式的对比"></a>生成方式的对比</h3><p>DOM是基于树结构生成xml文件的，SAX是基于事件生成。JDOM与DOM4J是基于底层API生成的。DOM方式方便修改删除DOM树，但是性能较低，而SAX性能较高，但是不方便修改。</p>
<p><strong>四种生成方式性能对比：sax最快、jdom第二、dom4j第三、dom最慢</strong></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><p>网络编程：两台电脑如果要通信需要满足以下条件：</p>
<ol>
<li>两台主机要有唯一的标识也就是ip地址</li>
<li>要有共同的语言，也就是协议</li>
<li>要有相应的端口号，用来辨别不同应用程序</li>
</ol>
<p><strong>TCP/IP是目前应用最为广泛的协议，是以TCP和IP为基础的不同层次上多个协议的集合，两个主机要进行通信就要遵守TCP（传输控制协议）和IP（互联网协议）协议。</strong></p>
<p><strong>在实际应用中，会将网络分层，常见的会将网络分为5层，分别是应用层、传输层、网络层、数据链路层、物理层。 而TCP与IP实在第4层传输层，应用层是用户直接接触的，包括HTTP协议、FTP协议、SMTP协议、Telnet远程登录服务都是应用层的协议。</strong></p>
<p><strong>ip地址是每台计算机的唯一标示，目前使用较多的版本是IPV4，在这个版本中定义了IP地址的长度为32位的2进制</strong></p>
<p><strong>端口号是用来区分不同的应用程序，每一个应用都有唯一的端口号，用来标识不同的程序，端口号范围为0~65535，其中0~1023为系统所保留，自定义端口号最好使用1023以后的端口号。</strong></p>
<p><strong>IP地址和端口号就组成了所谓的Socket，Socket是网络上运行的程序之间双向通信链路的终结点，是TCP和UDP的基础。</strong></p>
<p>两台主机要互相通信，首先要知道对方的IP地址，知道对方的IP地址之后要知道对方的端口号。知道IP地址加端口号就能互相通信了</p>
<p><strong>常用的协议与其端口号：http：80；  ftp：21；  telnet：23</strong></p>
<h2 id="java中的网络通信"><a href="#java中的网络通信" class="headerlink" title="java中的网络通信"></a>java中的网络通信</h2><p>Java中针对网络通信的不同层次，提供了四大类。</p>
<ol>
<li>InetAddress： 用于标识网络上的硬件资源。比如IP地址</li>
<li>URL:统一资源定位符  通过URL可以读取或写入网络上的数据</li>
<li>Sockets： 使用TCP协议实现网络通讯</li>
<li>Datagram： 使用UDP协议，将数据保存在数据报中，进行网络通讯</li>
</ol>
<h2 id="Java中网络相关API"><a href="#Java中网络相关API" class="headerlink" title="Java中网络相关API"></a>Java中网络相关API</h2><h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> //获取本地主机</span><br><span class="line">InetAddress id = InetAddress.getLocalHost();</span><br><span class="line">// 获取主机地址</span><br><span class="line">System.out.println(id.getHostAddress());</span><br><span class="line">// 获取主机名字</span><br><span class="line">System.out.println(id.getHostName());</span><br><span class="line">// id就是主机名字加主机地址</span><br><span class="line">System.out.println(id);</span><br><span class="line">// 通过主机名字获取主机</span><br><span class="line">InetAddress id1 = InetAddress.getByName(&quot;PC&quot;);</span><br><span class="line">// 通过IP地址获取主机</span><br><span class="line">InetAddress id2 = InetAddress.getByAddress(id.getAddress());</span><br></pre></td></tr></table></figure>
<h3 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h3><p><strong>URL是表示网络上某一资源的地址，URL由两部分组成，协议名和资源名，中间用冒号隔开。</strong></p>
<p>使用url类获取网页内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建url实例，并指定网址</span><br><span class="line">   URL url = new URL(&quot;http://www.baidu.com&quot;);</span><br><span class="line">   // 使用输出流与openStream方法生成百度的主页内容</span><br><span class="line">   InputStream is = url.openStream();</span><br><span class="line">   FileOutputStream fos = new FileOutputStream(new File(&quot;demo/baidu.html&quot;));</span><br><span class="line">   byte[] b = new byte[8 * 1024];</span><br><span class="line">   while (is.read(b,0,b.length) != -1)&#123;</span><br><span class="line">       fos.write(b,0,b.length);</span><br><span class="line">       fos.flush();</span><br><span class="line">   &#125;</span><br><span class="line">   is.close();</span><br><span class="line">   fos.close();</span><br></pre></td></tr></table></figure>
<h3 id="基于TCP的网络编程"><a href="#基于TCP的网络编程" class="headerlink" title="基于TCP的网络编程"></a>基于TCP的网络编程</h3><p><strong>TCP协议是面向连接，它是可靠的、有序的，以字节流的方式发送数据。TCP在通信之前，需要建立连接，以保证数据传输的可靠性。在Java中使用Socket以及ServerSocket这两个类实现TCP通信的，其中Socket是客户端需要实现的，而ServerSocket是服务器端实现。</strong></p>
<h4 id="通过Socket实现TCP编程"><a href="#通过Socket实现TCP编程" class="headerlink" title="通过Socket实现TCP编程"></a>通过Socket实现TCP编程</h4><p><strong>Socket通信模顺序：Server建立服务端并等待请求，客户端创建连接并向服务端发送请求，服务端接受请求并创建连接，客户端与服务端使用io流开始通信，通信完毕关闭相关资源。</strong></p>
<p>代码实现：</p>
<p>客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建客户端Socket实例</span><br><span class="line">Socket socket = new Socket(&quot;192.168.17.1&quot;,9999);</span><br><span class="line">// 获取Socket中的输出流</span><br><span class="line">OutputStream os = socket.getOutputStream();</span><br><span class="line">// 往输出流中写入数据</span><br><span class="line">os.write(1);</span><br><span class="line">os.flush();</span><br><span class="line">// 获取Socket中的输入流</span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line">// 读取输入流中的数据</span><br><span class="line">int i ;</span><br><span class="line">while ((i = is.read()) != -1)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭资源</span><br><span class="line">socket.shutdownInput();</span><br><span class="line">socket.shutdownOutput();</span><br><span class="line">is.close();</span><br><span class="line">os.close();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>
<p>服务器端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建服务端的Socket对象</span><br><span class="line">ServerSocket ss = new ServerSocket(9999);</span><br><span class="line">// 监听端口</span><br><span class="line">Socket socket = ss.accept();</span><br><span class="line">// 获取Socket中的输出流</span><br><span class="line">OutputStream os = socket.getOutputStream();</span><br><span class="line">// 使用输入流写入数据</span><br><span class="line">os.write(2);</span><br><span class="line">// 获取Socket中的输入流</span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line">// 读取输入流中的数据</span><br><span class="line">int i;</span><br><span class="line">while((i = is.read()) != -1)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭资源</span><br><span class="line">socket.shutdownOutput();</span><br><span class="line">socket.shutdownInput();</span><br><span class="line">os.close();</span><br><span class="line">is.close();</span><br><span class="line">socket.close();</span><br><span class="line">ss.close();</span><br></pre></td></tr></table></figure>
<p><strong>在创建Socket对象时需要注意的是，需要先写后读，如果先读后写，会导致输出流写入的数据另一端不能正确接收到</strong></p>
<h4 id="使用多线程实现基于TCP的多客户端与服务器端通信"><a href="#使用多线程实现基于TCP的多客户端与服务器端通信" class="headerlink" title="使用多线程实现基于TCP的多客户端与服务器端通信"></a>使用多线程实现基于TCP的多客户端与服务器端通信</h4><p>服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // 创建服务端的Socket对象</span><br><span class="line">ServerSocket ss = new ServerSocket(9999);</span><br><span class="line">int count = 0;</span><br><span class="line">// 监听端口</span><br><span class="line">while (true) &#123;</span><br><span class="line">    // 监听端口，会堵塞当前线程，直到有监听结果</span><br><span class="line">    Socket socket = ss.accept();</span><br><span class="line">    // 创建线程类并准备运行</span><br><span class="line">    ServerThread st = new ServerThread(socket);</span><br><span class="line">    st.start();</span><br><span class="line">    // 客户端数量</span><br><span class="line">    System.out.println(&quot;当前有&quot; + (++count) + &quot;个客户端连接&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器线程处理类：创建一个类继承Thread并重写run方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // Socket对象</span><br><span class="line">Socket socket = null;</span><br><span class="line">// 构造方法</span><br><span class="line">public ServerThread()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ServerThread(Socket socket)&#123;</span><br><span class="line">    this.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line">// 重写run方法</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    OutputStream os = null;</span><br><span class="line">    InputStream is = null;</span><br><span class="line">    OutputStreamWriter osw = null;</span><br><span class="line">    InputStreamReader isr = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取Socket中的输出流并包装为字符输出流</span><br><span class="line">        os = socket.getOutputStream();</span><br><span class="line">        osw = new OutputStreamWriter(os);</span><br><span class="line">        // 使用字符输出流写入数据</span><br><span class="line">        osw.write(&quot;我是服务器线程类&quot;);</span><br><span class="line">        osw.flush();</span><br><span class="line">        // 获取Socket中的输入流并包装为字符输入流</span><br><span class="line">        is = socket.getInputStream();</span><br><span class="line">        isr = new InputStreamReader(is);</span><br><span class="line">        // 读取输入流中的数据</span><br><span class="line">        int i;</span><br><span class="line">        char[] bytes = new char[8 * 1024];</span><br><span class="line">        while ((i = isr.read(bytes,0,bytes.length)) != -1) &#123;</span><br><span class="line">            System.out.println(new String(bytes,0,i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally&#123;</span><br><span class="line">        // 关闭资源</span><br><span class="line">        try &#123;</span><br><span class="line">            if (osw != null)</span><br><span class="line">                osw.close();</span><br><span class="line">            if (isr != null)</span><br><span class="line">                isr.close();</span><br><span class="line">            if (os != null)</span><br><span class="line">                os.close();</span><br><span class="line">            if (is != null)</span><br><span class="line">                is.close();</span><br><span class="line">            if (socket != null)</span><br><span class="line">                socket.close();</span><br><span class="line">        &#125;catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当每次有客户端连接时都会使用新线程来连接。</p>
<h3 id="基于UDP的网络编程"><a href="#基于UDP的网络编程" class="headerlink" title="基于UDP的网络编程"></a>基于UDP的网络编程</h3><p><strong>UDP协议是无连接、不可靠、无序的。相对来说UDP的传输速度回比较快。UDP是以数据报作为数据传输的载体，使用UDP协议进行数据传输时，首先需要将需要传输的数据封装成数据报，在数据报中指明数据所要到达的Socket（主机地址和端口号），然后在将数据报发送出去。</strong></p>
<h4 id="使用数据报实现UDP编程"><a href="#使用数据报实现UDP编程" class="headerlink" title="使用数据报实现UDP编程"></a>使用数据报实现UDP编程</h4><p><strong>java中有关UDP协议的有DatagramPacket、DatagramSocket两个类，分别表示数据报以及进行端对端通信的类。 </strong></p>
<p>服务器端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // 创建UDPSocket实例，用来发送及接受信息</span><br><span class="line">DatagramSocket ds = new DatagramSocket(8800);</span><br><span class="line">// 接收信息</span><br><span class="line">//创建byte数组用来保存接收到的信息</span><br><span class="line">byte[] bytes = new byte[20 * 1024];</span><br><span class="line">// 创建数据报实例</span><br><span class="line">DatagramPacket dp = new DatagramPacket(bytes, bytes.length);</span><br><span class="line">// 使用UDPSocket的receive方法接受数据，这个方法在收到数据之前会一直阻塞</span><br><span class="line">ds.receive(dp);</span><br><span class="line">System.out.println(new String(bytes));</span><br><span class="line"></span><br><span class="line">// 创建byte数组保存需要发送的数据</span><br><span class="line">byte[] data = &quot;我是服务器端&quot;.getBytes();</span><br><span class="line">// 创建数据报实例并使用UDPSocket的send方法发送数据</span><br><span class="line">DatagramPacket dp2 = new DatagramPacket(data,data.length,dp.getAddress(),dp.getPort());</span><br><span class="line">ds.send(dp2);</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // 创建UDPSocket实例用来发送及接受数据</span><br><span class="line">DatagramSocket ds = new DatagramSocket();</span><br><span class="line"></span><br><span class="line">// 发送数据</span><br><span class="line">// 需要发送的数据</span><br><span class="line">byte[] bytes = &quot;我是客户端&quot;.getBytes();</span><br><span class="line">// 创建数据报并发送</span><br><span class="line">DatagramPacket dp = new DatagramPacket(bytes,bytes.length, InetAddress.getLocalHost(),8800);</span><br><span class="line">ds.send(dp);</span><br><span class="line"></span><br><span class="line">// 接收数据</span><br><span class="line">// 用来保存接收到的数据</span><br><span class="line">byte[] data = new byte[8 * 1024];</span><br><span class="line">// 创建数据报并接受数据</span><br><span class="line">DatagramPacket dp2 = new DatagramPacket(data,data.length,InetAddress.getLocalHost(),8800);</span><br><span class="line">ds.receive(dp2);</span><br><span class="line">System.out.println(new String(data));</span><br></pre></td></tr></table></figure>
<h4 id="使用多线程实现基于UDP的多客户端与服务端连接"><a href="#使用多线程实现基于UDP的多客户端与服务端连接" class="headerlink" title="使用多线程实现基于UDP的多客户端与服务端连接"></a>使用多线程实现基于UDP的多客户端与服务端连接</h4><p>服务器端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建UDPSocket实例，用来发送及接受信息</span><br><span class="line">DatagramSocket ds = new DatagramSocket(8800);</span><br><span class="line">// 接收信息</span><br><span class="line">//创建byte数组用来保存接收到的信息</span><br><span class="line">byte[] bytes = new byte[20 * 1024];</span><br><span class="line">// 创建数据报实例</span><br><span class="line">DatagramPacket dp = new DatagramPacket(bytes, bytes.length);</span><br><span class="line">int count = 0;</span><br><span class="line">while (true)&#123;</span><br><span class="line">    // 使用UDPSocket的receive方法接受数据，这个方法在收到数据之前会一直阻塞</span><br><span class="line">    ds.receive(dp);</span><br><span class="line">    // 创建线程类并准备运行</span><br><span class="line">    ServerThread st = new ServerThread(ds,bytes,dp);</span><br><span class="line">    st.start();</span><br><span class="line">    System.out.println(&quot;当前有&quot; + (++count) + &quot;个客户端已连接&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器线程类代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // 全局变量</span><br><span class="line">DatagramSocket ds = null;</span><br><span class="line">byte[] bytes = null;</span><br><span class="line">DatagramPacket dp = null;</span><br><span class="line">//构造方法</span><br><span class="line">public ServerThread(DatagramSocket ds,byte[] bytes,DatagramPacket dp)&#123;</span><br><span class="line">    this.ds = ds;</span><br><span class="line">    this.bytes = bytes;</span><br><span class="line">    this.dp = dp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重写run方法</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    // 输出接收到的数据</span><br><span class="line">    System.out.println(new String(bytes));</span><br><span class="line">    // 输出客户端IP地址</span><br><span class="line">    System.out.println(dp.getAddress());</span><br><span class="line">    // 创建byte数组保存需要发送的数据</span><br><span class="line">    byte[] data = &quot;我是服务器端&quot;.getBytes();</span><br><span class="line">    // 根据已连接的客户端的IP地址与端口号创建数据报实例并使用UDPSocket的send方法发送数据</span><br><span class="line">    DatagramPacket dp2 = new DatagramPacket(data,data.length,dp.getAddress(),dp.getPort());</span><br><span class="line">    try &#123;</span><br><span class="line">        // 往连接的客户端发送信息</span><br><span class="line">        ds.send(dp2);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="网络编程总结"><a href="#网络编程总结" class="headerlink" title="网络编程总结"></a>网络编程总结</h3><pre><code>1. 多线程的优先级，当服务器需要与多个客户端进行通信，这个时候就需要注意线程的优先级的问题。未设置优先级可能会导致云心速度较慢，这时候可以降低优先级。而设置优先级可以通过setPriority方法。
2. 基于TCOP的Scoket编程时会使用IO流，这时候如果关闭io流，则Scoket也会被关闭，所以一般补不会关闭IO流，直接关闭Scoket即可。
3. 在通信时可以使用ObjectOutputStream与ObjectInputStream来传输对象
</code></pre><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p> <strong>进程与线程:进程是程序或者任务的执行过程，而执行过程是动态性的，只有当程序运行了之后才能称为进程。进程一般持有共享资源如文件、内存以及线程。进程是资源和线程的载体，程序在在运行时是要从内存中读取数据，所以要为进程分配内存。</strong></p>
<p> <strong>线程是系统中最小的执行单元，同一个进程中有多个线程，线程共享进程的资源。线程之间的通信称为线程的交互，交互的方式分为互斥与同步。</strong></p>
<p> <strong>互斥是指某个资源同一时间只能由一个线程使用，当某个线程使用了之后后来的线程需要等待之前的线程使用完。而同步是指多个线程同时完成某个功能。计算机中CPU在同一时间只能运行一条线程。</strong></p>
<h2 id="java中的线程"><a href="#java中的线程" class="headerlink" title="java中的线程"></a>java中的线程</h2><p> <strong>Java中对线程的支持体现在Thread类以及Runnable接口，在Thrad类以及Runnable接口中都有一个run()方法，run方法提供了这个线程需要执行的代码。</strong></p>
<h3 id="线程的常用方法："><a href="#线程的常用方法：" class="headerlink" title="线程的常用方法："></a>线程的常用方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">strat()  是当前线程准备运行，只有使用这个方法，线程才会运行。</span><br><span class="line"></span><br><span class="line">sleep()  使当前线程休眠</span><br><span class="line"></span><br><span class="line">join()   使其他线程等待当前线程终止</span><br><span class="line"></span><br><span class="line">yield()  静态的，使当前运行线程释放处理器资源</span><br><span class="line"></span><br><span class="line">currentThread()   静态的，返回当前运行的线程引用</span><br></pre></td></tr></table></figure>
<h3 id="继承Thread类并重写run-方法"><a href="#继承Thread类并重写run-方法" class="headerlink" title="继承Thread类并重写run()方法"></a>继承Thread类并重写run()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> public void run() &#123;</span><br><span class="line">    // 统计线程运行次数</span><br><span class="line">    int count = 0;</span><br><span class="line">    System.out.println(getName() + &quot;开始执行&quot;);</span><br><span class="line">    // 循环运行线程</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        System.out.println(&quot;第&quot; + (++count) + &quot;次执行&quot; + getName());</span><br><span class="line">        // 当运行次数等于100时退出循环</span><br><span class="line">        if (count == 100)</span><br><span class="line">            break;</span><br><span class="line">        // 没运行10次休眠1秒</span><br><span class="line">        if (count % 10 == 0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(getName() + &quot;结束执行&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承Runnable接口并实现run-方法"><a href="#继承Runnable接口并实现run-方法" class="headerlink" title="继承Runnable接口并实现run()方法"></a>继承Runnable接口并实现run()方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public void run() &#123;</span><br><span class="line">    // 统计循环次数</span><br><span class="line">    int count = 0;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot;开始执行&quot;);</span><br><span class="line">    // 循环执行</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        System.out.println(&quot;第&quot; + (++count) + &quot;次执行&quot;);</span><br><span class="line">        // 执行100次退出循环</span><br><span class="line">        if (count == 100)</span><br><span class="line">            break;</span><br><span class="line">        // 执行10次休眠1秒</span><br><span class="line">        if (count % 10 == 0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.currentThread().sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot;结束执行&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行线程"><a href="#运行线程" class="headerlink" title="运行线程"></a>运行线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ThreadTest tt = new ThreadTest();</span><br><span class="line">   Thread t = new Thread(new RunnableTest(),&quot;Runnable&quot;);</span><br><span class="line">   tt.setName(&quot;thread&quot;);</span><br><span class="line">   tt.start();</span><br><span class="line">   t.start();</span><br></pre></td></tr></table></figure>
<p><strong>当运行之后发现两条线程是交替运行的，这是因为计算机中CPU在同一时间只能运行一条线程，而一条线程运行中是可能会被另一条线程抢到CPU的执行权。</strong></p>
<h2 id="利用多线程模拟战争"><a href="#利用多线程模拟战争" class="headerlink" title="利用多线程模拟战争"></a>利用多线程模拟战争</h2><p> 部队类:实现Runnable接口并实现run方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> // volatile保证了线程可以正确读取到值被其他线程修改之后的值</span><br><span class="line">volatile boolean keepRunning = true;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    while (keepRunning)&#123;</span><br><span class="line">        for (int i = 1; i &lt;= 5; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;第&quot; + i + &quot;次进攻&quot;);</span><br><span class="line">            // yield方法保证每次攻击之后别人也有出手的机会</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>英雄类：继承Thread类并重写run方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public void run() &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot;开始战斗&quot;);</span><br><span class="line">    for (int i = 1; i &lt;= 10; i++)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;攻击了&quot; + i + &quot;次&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot;结束了战斗&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>舞台类：继承Thread类并重写run方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> public void run() &#123;</span><br><span class="line">    // 创建军队线程并让他们准备运行</span><br><span class="line">    ArmyRunnable army = new ArmyRunnable();</span><br><span class="line">    Thread sui1 = new Thread(army,&quot;隋军&quot;);</span><br><span class="line">    Thread free1 = new Thread(army,&quot;起义军&quot;);</span><br><span class="line">    sui1.start();</span><br><span class="line">    free1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 让当前这个线程休眠50毫秒，在执行后边的代码</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(50);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建英雄人物线程</span><br><span class="line">    Thread kpt = new KeyPersonThread(&quot;程咬金&quot;);</span><br><span class="line">    kpt.start();</span><br><span class="line"></span><br><span class="line">    // 结束军队线程的循环</span><br><span class="line">    army.keepRunning = false;</span><br><span class="line"></span><br><span class="line">    // 让当前线程休眠2秒</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*         让主线程等待kpt线程执行完才会执行,而如果把以下代码放到结束军队线程的循环前面，则主线程</span><br><span class="line">      会一直等待军队线程的停止，不会执行结束军队线程的循环代码，军队线程就不会结束循环，就会陷入死循环。</span><br><span class="line">      综上所述，join方法会让在这个线程使用join方法的线程等待调用join方法的线程结束才会继续执行。*/</span><br><span class="line"></span><br><span class="line">    // 让所有线程等待kpt线程结束</span><br><span class="line">    try &#123;</span><br><span class="line">        kpt.join();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="java线程的停止"><a href="#java线程的停止" class="headerlink" title="java线程的停止"></a>java线程的停止</h2><p><strong>停止线程不推荐使用stop方法停止，因为stop方法是直接停止线程，导致不知道线程执行到了哪一步，也不能做清理工作。</strong></p>
<p><strong>确停止线程的方式是为线程设置退出旗标，当在别的线程达到退出的条件时，修改旗标以达到停止线程：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 退出旗标，volatile保证了当前线程可以正确读取到被其他线程修改之后的值</span><br><span class="line">   volatile boolean keepRunning = true;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       while (keepRunning)&#123;</span><br><span class="line">           for (int i = 1; i &lt;= 5; i++)&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + &quot;第&quot; + i + &quot;次进攻&quot;);</span><br><span class="line">               // yield方法保证每次攻击之后别人也有出手的机会</span><br><span class="line">               Thread.yield();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> <strong>interrupt()停止线程方法并不能正确停止线程，因为它是中断当前线程，而不是停止，当线程中断之后，在调用sleep方法或者wait方法时会重置中断状态以及抛出中断异常。这就是sleep或者wait方法需要try Catch的原因，正确的停止线程方法应该是上边提到的设置旗标方法。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">    // 创建线程并准备运行</span><br><span class="line">    Thread thread = new InterruptTest();</span><br><span class="line">    System.out.println(&quot;线程启动&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line">    // 当前线程休眠3秒</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    // 中断线程</span><br><span class="line">    System.out.println(&quot;中断线程&quot;);</span><br><span class="line">  /*  中断线程，当main方法使用sleep方法或者wait方法时线程会继续运行但没有抛出异常，当线程被中断之后</span><br><span class="line">    这个线程调用sleep方法会抛出异常且线程继续运行*/</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;线程结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    // 当这个线程没有中断的时候循环</span><br><span class="line">    while (true)&#123;</span><br><span class="line">        System.out.println(&quot;运行线程...&quot;);</span><br><span class="line">        long time = System.currentTimeMillis();</span><br><span class="line">       while ((System.currentTimeMillis() - time) &lt; 1000)&#123;</span><br><span class="line">           /*减少屏幕输出的空循环，用sleep会抛出异常,当从外层进入到内层循环时，如果运行时间小于1000毫秒</span><br><span class="line">            内层循环会一直循环*/</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上边代码运行结果为线程不能正常停止也不会抛出异常，而当把死循环改为是否中断为条件循环就能正常停止循环，但是在run方法里不能使用sleep方法，负责会抛出异常且不能正常停止线程：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> public void run() &#123;</span><br><span class="line">    // 当这个线程没有中断的时候循环</span><br><span class="line">    while (!this.isInterrupted())&#123;</span><br><span class="line">        System.out.println(&quot;运行线程...&quot;);</span><br><span class="line">        long time = System.currentTimeMillis();</span><br><span class="line">        // 当循环条件为线程是否中断时，这个方法可以达到休眠1秒的作用且不会抛出异常</span><br><span class="line">       while ((System.currentTimeMillis() - time) &lt; 1000)&#123;</span><br><span class="line">           /*减少屏幕输出的空循环，用sleep会抛出异常,当从外层进入到内层循环时，如果运行时间小于1000毫秒</span><br><span class="line">            内层循环会一直循环*/</span><br><span class="line">        &#125;</span><br><span class="line">       // 使用sleep方法会抛出异常，且线程不能正确停止</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>综上所述，正确的停止线程方式为为线程设置循环条件，当要结束线程时，修改循环条件来达到停止线程，而需要注意的是，循环条件要用volatile修饰符修饰，防止当前线程读取不到被其他线程修改之后的值：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 循环条件，volatile修饰符可以保证本线程正确读取到被其他线程修改之后的值</span><br><span class="line">volatile boolean flg = true;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    // 创建线程并准备运行</span><br><span class="line">    Thread thread = new InterruptTest();</span><br><span class="line">    System.out.println(&quot;线程启动&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line">    // 当前线程休眠3秒</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    // 中断线程</span><br><span class="line">    System.out.println(&quot;中断线程&quot;);</span><br><span class="line">    // 把Thread强制转换为InterruptTest类并把循环条件设置为false来停止线程</span><br><span class="line">    ((InterruptTest) thread).flg = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;线程结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    // 根据条件循环</span><br><span class="line">    while (flg)&#123;</span><br><span class="line">        System.out.println(&quot;运行线程...&quot;);</span><br><span class="line">       // 使用sleep方法会抛出异常，且线程不能正确停止</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程的同步与互斥"><a href="#线程的同步与互斥" class="headerlink" title="线程的同步与互斥"></a>线程的同步与互斥</h2><p><strong>互斥：在同一时间只能由一条线程操作数据或临界区。</strong></p>
<p><strong>同步：同步是线程之间的通信机制。也就是说当一条线程操作完之后通过某种方法告诉其他线程当前线程执行完毕。</strong></p>
<p><strong>当我们使用多线程时，有时会导致数据不准确，这是因为争用条件，争用条件：当多个线程同时共享访问同一数据（内存区域）时，每个线程都尝试操作该数据，从而导致数据被破坏，这种现象称为争用条件，通过一个多线程操作数组内的元素的值得例子来看：</strong></p>
<p>数组类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个数组用来让线程执行数组中的元素增加和减少</span><br><span class="line">  private final double[] energyBoxs;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   *</span><br><span class="line">   * @param n   数组大小</span><br><span class="line">   * @param initialEnergy   数组元素的值</span><br><span class="line">   */</span><br><span class="line">  // 构造方法，循环为数组中的每个元素赋值</span><br><span class="line">  public EnergyStytem(int n,double initialEnergy)&#123;</span><br><span class="line">      energyBoxs = new double[n];</span><br><span class="line">      for (int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">          energyBoxs[i] = initialEnergy;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   *</span><br><span class="line">   * @param from  数组中的第from个成员，用来减Amount</span><br><span class="line">   * @param to    数组中的第to个成员，用来加amount</span><br><span class="line">   * @param amount    成员加减的值</span><br><span class="line">   */</span><br><span class="line">  public void transfer(int from,int to, double amount)&#123;</span><br><span class="line">      // 判断第from个成员的值是否大于需要减少的，如果小于，则退出方法</span><br><span class="line">      if (energyBoxs[from] &lt; amount)</span><br><span class="line">          return;</span><br><span class="line">      // 获取当前线程名字</span><br><span class="line">      System.out.println(Thread.currentThread().getName());</span><br><span class="line">      // 使目标元素减少</span><br><span class="line">      energyBoxs[from] -= amount;</span><br><span class="line">      System.out.printf(&quot;从%d转移%10.2f单位能量到%d%n&quot;,from,amount,to);</span><br><span class="line">      //  使目标元素增加</span><br><span class="line">      energyBoxs[to] += amount;</span><br><span class="line">      System.out.printf(&quot;能量总和：%10.2f%n&quot;,getTotalEnergies());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取数组的全部值</span><br><span class="line">  private double getTotalEnergies() &#123;</span><br><span class="line">      double sum = 0;</span><br><span class="line">      for (double d : energyBoxs</span><br><span class="line">           ) &#123;</span><br><span class="line">          sum += d;</span><br><span class="line">      &#125;</span><br><span class="line">      return sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取数组长度</span><br><span class="line">  public int getEnergyBoxesLength()&#123;</span><br><span class="line">      return energyBoxs.length;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>操作数组成语值的类，继承Runnable接口来创建线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 能量系统类</span><br><span class="line">  private EnergyStytem energyStytem;</span><br><span class="line">  // 目标元素</span><br><span class="line">  private int fromBox;</span><br><span class="line">  // 最大转移值</span><br><span class="line">  private double maxAmount;</span><br><span class="line">  // 最大休眠时间</span><br><span class="line">  private final int DELAY = 10;</span><br><span class="line"></span><br><span class="line">  // 构造方法</span><br><span class="line">  public EnergyTransfer(EnergyStytem energyStytem, int fromBox, double maxAmount)&#123;</span><br><span class="line">      this.energyStytem = energyStytem;</span><br><span class="line">      this.fromBox = fromBox;</span><br><span class="line">      this.maxAmount = maxAmount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 能量转移方法</span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      while(true)&#123;</span><br><span class="line">          // 随机获取目标元素的值范围为0-数组最大长度</span><br><span class="line">          int toBox = (int) (energyStytem.getEnergyBoxesLength() * Math.random());</span><br><span class="line">          // 随机获取转移的值，范围为0-maxAmount</span><br><span class="line">          double amount = maxAmount * Math.random();</span><br><span class="line">          // 转移方法</span><br><span class="line">          energyStytem.transfer(fromBox,toBox,amount);</span><br><span class="line">          // 使线程休眠随机毫秒，范围为0-DELAY</span><br><span class="line">          try &#123;</span><br><span class="line">              Thread.sleep((int) (DELAY * Math.random()));</span><br><span class="line">          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>实验类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 数组长度</span><br><span class="line">  public static final int BOX_AMOUNT = 100;</span><br><span class="line">  // 数组元素的值</span><br><span class="line">  public static final double INITIAL_ENERGY = 1000;</span><br><span class="line">  public static void main (String[] args)&#123;</span><br><span class="line">      // 创建能量系统对象</span><br><span class="line">      EnergyStytem es = new EnergyStytem(BOX_AMOUNT,INITIAL_ENERGY);</span><br><span class="line">      // 循环创建能量转移线程并准备运行</span><br><span class="line">      for(int i = 0; i &lt; BOX_AMOUNT; i++)&#123;</span><br><span class="line">          EnergyTransfer tc = new EnergyTransfer(es,i,INITIAL_ENERGY);</span><br><span class="line">          Thread t = new Thread(tc,&quot;转移线程&quot; + i);</span><br><span class="line">          t.start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行上边代码之后会发现在运行过程中数组元素的总值有时会小于100000，而正确的总值应该为数组长度*元素的值也就是100000，这就是因为争用条件。</strong></p>
<h2 id="线程的争用条件"><a href="#线程的争用条件" class="headerlink" title="线程的争用条件"></a>线程的争用条件</h2><p><strong>如何产生条件征用的：在代码运行的在某一时刻，多个线程操作同一目标，但是同一时间CPU只能运行一个线程，线程之间的调度是通过分时&amp;抢占完成的，假设线程A获得了CPU的执行时间，首先从内存区域中取得需要修改的数据到线程的内存中，然后修改。这时线程A执行时间耗尽，执行线程B，线程B同样取得数据并修改，然后写入到原内存区域中，线程B执行完毕之后再执行线程A，这时候线程A的执行结果就会覆盖线程B。</strong></p>
<h2 id="java中线程的互斥与同步"><a href="#java中线程的互斥与同步" class="headerlink" title="java中线程的互斥与同步"></a>java中线程的互斥与同步</h2><p><strong>Java中实现互斥：Java中是通过synchronize关键字实现互斥的，synchronize可以出现在方法之上，也可以出现在方法体之中，而synchronize需要通过传进一个Object对象来实现互斥：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> // 对象锁</span><br><span class="line">private final Object OBJCET_LOCK = new Object();</span><br><span class="line">public void transfer(int from,int to, double amount)&#123;</span><br><span class="line">    synchronized (OBJCET_LOCK)&#123;</span><br><span class="line">        // 判断第from个成员的值是否大于需要减少的，如果小于，则退出方法</span><br><span class="line">        // 退出之后，因为这条线程还可能抢到CPU执行权，然后在获取锁的开销，因此这不是个好的方法</span><br><span class="line">    /*    if (energyBoxs[from] &lt; amount)</span><br><span class="line">            return;*/</span><br><span class="line">    // 当条件不满足时让这个线程等待，而不会继续竞争CPU资源</span><br><span class="line">    while (energyBoxs[from] &lt; amount)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            OBJCET_LOCK.wait();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        // 获取当前线程名字</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        // 使目标元素减少</span><br><span class="line">        energyBoxs[from] -= amount;</span><br><span class="line">        System.out.printf(&quot;从%d转移%10.2f单位能量到%d%n&quot;,from,amount,to);</span><br><span class="line">        //  使目标元素增加</span><br><span class="line">        energyBoxs[to] += amount;</span><br><span class="line">        System.out.printf(&quot;能量总和：%10.2f%n&quot;,getTotalEnergies());</span><br><span class="line">        // 当某个线程执行完毕之后，告诉所有其他线程你可以再次尝试判断能否继续执行</span><br><span class="line">        OBJCET_LOCK.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在以上代码中，通过synchronized关键字实现了线程的互斥操作，通过Object的wait()与notifyAll()方法实现了线程的同步。当线程调用了Objec对象的wait()方法之后，当前线程就会至于Object对象的等待集合（wait set）中</strong></p>
<p><strong>互斥：关键数据在同一时间只能被一个线程访问，Java中由synchronized(intrinsic lock)实现，synchronized相对于给代码加上一把锁，每次只给多个线程之中一个线程钥匙。</strong></p>
<p><strong>同步：当前由于某些条件不具备使当前线程处于等待状态，当其他线程执行完毕可能会使得条件具备，这时候就需要同步来告诉当前线程不需等待了。Java中实现同步通过Objcet对象的wait()/notify()/notifyAll()方法实现</strong></p>
<p><strong>当线程A需要访问共享资源时，首先线程A需要获得锁，获得锁之后进入临界区开始操作，操作过程中如果某种条件不被满足，调用锁对象的wait()方法,在调用wait()方法之后首先释放锁资源，然后进入锁对象的wait set。而这时临界区的所资源被释放，线程B获得锁并进入临界区开始操作，线程B执行完某些操作需要通知wait set中的线程时，会调用notify()方法，而notifyAll()方法会唤醒锁对象的waitSet中的一条线程，使得这条线程有机会重新获得CPU得执行权。而notifyAll()方法会唤醒锁对象的waitSet中的所有线程去争取CPU的执行权</strong></p>
<h2 id="多线程总结"><a href="#多线程总结" class="headerlink" title="多线程总结"></a>多线程总结</h2><ol>
<li><strong>线程的创建可以通过继承Thread类并重写run()方法以及实现Runnable接口及其中的run()方法</strong></li>
<li><strong>volatile关键字可以保证当前线程可以正确获得被其他线程修改的数据</strong></li>
<li><strong>线程之间的争用条件</strong></li>
<li><strong>线程之间的互斥通过synchronized关键字实现</strong></li>
<li><strong>线程的同步通过锁对象的wait()/notify()/notifyAll()方法实现</strong></li>
</ol>
<h1 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h1><p><strong>jdbc的全称为java Data Base Connectivity，它是java应用程序与数据库之间的连接工具，不同的数据库都会实现这个接口，java应用程序就可以通过jdbc连接数据库</strong></p>
<h2 id="jdbc的使用"><a href="#jdbc的使用" class="headerlink" title="jdbc的使用"></a>jdbc的使用</h2><ol>
<li>加载驱动程序，通过Class.forName()方法来加载，需要加载那个驱动程序就把名字当做参数传进去就可以了。加载数据库驱动需要对应的数据库驱动jar包</li>
<li>获得数据库连接，通过DriverManager.gerConnection()方法获得连接，需要把连接地址、用户名及密码当做参数传递进去</li>
<li>创建Statement对象并执行SQL语句</li>
</ol>
<h3 id="使用jdbc连接MySQL数据库"><a href="#使用jdbc连接MySQL数据库" class="headerlink" title="使用jdbc连接MySQL数据库"></a>使用jdbc连接MySQL数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 数据库连接地址常量，字符串含义为jdb连接方式，mysql数据库，连接地址，所需要连接的数据库</span><br><span class="line">   private static final String URL = &quot;jdbc:mysql://127.0.0.1:3306/test&quot;;</span><br><span class="line">   // 用户名常量</span><br><span class="line">   private static final String USER = &quot;root&quot;;</span><br><span class="line">   //密码常量</span><br><span class="line">   private static final String PASSWORD = &quot;root&quot;;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           // 通过反射加载驱动</span><br><span class="line">           Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">           // 通过地址、用户名、密码常量获取数据库连接</span><br><span class="line">           Connection connection = DriverManager.getConnection(URL,USER,PASSWORD);</span><br><span class="line">           // 通过连接获取Statement对象</span><br><span class="line">           Statement statement = connection.createStatement();</span><br><span class="line">           // SQL语句</span><br><span class="line">           String sql = &quot;SELECT * FROM imooc_goddess;&quot;;</span><br><span class="line">           // 通过Statement对象执行sql语句并返回结果集</span><br><span class="line">           ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">           // 遍历结果集,通过结果集的getString()方法获得值，其中参数为想要获取的列名</span><br><span class="line">           while (resultSet.next())&#123;</span><br><span class="line">               System.out.printf(resultSet.getString(&quot;user_name&quot;) + resultSet.getString(&quot;age&quot;));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">           System.out.printf(&quot;找不到这个类&quot;);</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; catch (SQLException e) &#123;</span><br><span class="line">           System.out.printf(&quot;SQL语句错误&quot;);</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用jdbc连接oracle数据库"><a href="#使用jdbc连接oracle数据库" class="headerlink" title="使用jdbc连接oracle数据库"></a>使用jdbc连接oracle数据库</h3><p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 数据库连接对象</span><br><span class="line">private static Connection con;</span><br><span class="line">// 数据库驱动目录</span><br><span class="line">private static final String DRIVER = &quot;oracle.jdbc.OracleDriver&quot;;</span><br><span class="line">// 连接URL，分别是ip地址、端口号及数据库的sid</span><br><span class="line">private static final String URL = &quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;;</span><br><span class="line">// 用户名及密码</span><br><span class="line">private static final String USERNAME = &quot;system&quot;;</span><br><span class="line">private static final String PASSWORD = &quot;root&quot;;</span><br><span class="line">// 静态代码块加载驱动及获取数据库连接</span><br><span class="line">static&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 通过反射加载驱动</span><br><span class="line">        Class.forName(DRIVER);</span><br><span class="line">        // 获取数据库连接</span><br><span class="line">        con = DriverManager.getConnection(URL,USERNAME,PASSWORD);</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(&quot;加载驱动失败&quot;);</span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(&quot;连接数据库失败&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 返回连接</span><br><span class="line">public static Connection getConnection()&#123;</span><br><span class="line">    return con;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数据库的sid可以通过在SQLPlus中查询实现:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select instance_name from  V$instance</span><br></pre></td></tr></table></figure>
<h4 id="jdbc调用Oracle数据库的存储过程"><a href="#jdbc调用Oracle数据库的存储过程" class="headerlink" title="jdbc调用Oracle数据库的存储过程"></a>jdbc调用Oracle数据库的存储过程</h4><p>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  // SQL语句，必须带有大括号且使用call关键字</span><br><span class="line">     String sql = &quot;&#123;call IMG_INSERT3(?,?)&#125;&quot;;</span><br><span class="line">// 获取执行存储过程对象</span><br><span class="line">     CallableStatement ps = con.prepareCall(sql);</span><br><span class="line">     // 设置占位符</span><br><span class="line">     ps.setInt(1,file.getId())</span><br><span class="line">     ps.setString(2,file.getFileName());</span><br><span class="line">     // 执行存储过程</span><br><span class="line">     ps.execute();</span><br></pre></td></tr></table></figure></p>
<h2 id="MVC三层架构"><a href="#MVC三层架构" class="headerlink" title="MVC三层架构"></a>MVC三层架构</h2><p><strong>MVC三层架构从上到下分别为View(视图层)、Control(控制层)、Model(模型层)以及最下边的DB(数据库)。模型层包括了对于数据库的映射类以及其中的方法（增删改查等）。控制层用来控制数据流通过程，调用模型层的方法并把结果包装起来交给视图层展示。视图层就是用来展示数据。</strong></p>
<p><strong>MVC架构的流程：视图层用来展示数据及把用户的行为传递给控制层，控制层则根据用户行为更新数据库及模型层，模型层把更新结果重新传递给控制层，控制层在把结果包装起来交给视图层展示</strong></p>
<p><strong>实际开发中，在了解需求之后，根据需求设计数据库，根据数据库设计模型层、根据模型层设计控制层及视图层</strong></p>
<p><strong>模型层包括了与数据库表中的映射-实体类，以及实现实体类方法的Dao文件夹。而通过预编译SQL语句PreparedStatement类可以防止SQL注入。例子：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 获取数据库连接</span><br><span class="line">Connection connection = DBUtil.getConnection();</span><br><span class="line">// SQL语句</span><br><span class="line">String sql = &quot;insert imooc_goddess(user_name,age,birthday) values(?,?,?)&quot;;</span><br><span class="line">// 通过连接获取PreparedStatement对象并把SQL语句传递进去</span><br><span class="line">PreparedStatement statement = connection.prepareStatement(sql);</span><br><span class="line">// 为SQL语句中的占位符设置值</span><br><span class="line">   statement.setString(1,goddess.getUserName());</span><br><span class="line">   statement.setInt(2,goddess.getAge());</span><br><span class="line">   statement.setDate(3,goddess.getBirthday());</span><br><span class="line">// 执行SQL</span><br><span class="line">   statement.execute();</span><br><span class="line">// 获取执行结果，结果为影响的行数</span><br><span class="line">statement.getUpdateCount()</span><br></pre></td></tr></table></figure>
<h3 id="模型层的注意事项："><a href="#模型层的注意事项：" class="headerlink" title="模型层的注意事项："></a>模型层的注意事项：</h3><ol>
<li><p><strong>SQL语句要用空格分开</strong></p>
</li>
<li><p><strong>实体类中Date属性分为Util下的与SQL包下的，有时导错包会导致往数据库中存储Date类型数据出错。因为SQL.Date中的日期只有年月日，没有时分秒，而Util.Date包括年月日时分秒，所有使用Util.Date往数据库中存储Date类型会导致时分秒全部变为0。SQL.Date没办法设置时间，每次插入的都是1970-1-1。所以实体类中的Date应该为Util下的，而PreparedStatement类的setDate中的参数是SQL.Date下的，所以要把Util下的Date转为SQL包下的：</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">new Sql.Date(Util.Date.getTime());</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>PreparedStatement余Statement的区别，Statement对象执行的是静态SQL语句，而PreparedStatement执行的是预编译SQL语句，PreparedStatement可以预防SQL语句注入，更安全，效率也更高</strong></li>
</ol>
<p>创建模型层并创建一个根据多个参数查询的代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 根据传进来的查询字段、查询条件、字段等于的值完成查询</span><br><span class="line">   public Goddess getGoddess(List&lt;Map&lt;String,Object&gt;&gt; parameters)&#123;</span><br><span class="line">       // 拼接SQL</span><br><span class="line">       StringBuilder sql = new StringBuilder(&quot;SELECT * FROM imooc_goddess WHERE 1=1 &quot;);</span><br><span class="line">       if (parameters != null &amp;&amp; parameters.size() &gt; 0)&#123;</span><br><span class="line">           for (Map&lt;String, Object&gt; parameter : parameters) &#123;</span><br><span class="line">               sql.append(&quot;AND &quot; + parameter.get(&quot;name&quot;) + &quot; &quot; + parameter.get(&quot;relation&quot;) + &quot; &quot; + &quot;&apos;&quot; + parameter.get(&quot;value&quot;) + &quot;&apos; &quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 获取数据库连接及根据SQL查询</span><br><span class="line">       Connection con = DBUtil.getConnection();</span><br><span class="line">       Goddess g = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           PreparedStatement st = con.prepareStatement(sql.toString());</span><br><span class="line">           ResultSet rs = st.executeQuery();</span><br><span class="line">           while (rs.next())&#123;</span><br><span class="line">               g = new Goddess();</span><br><span class="line">               g.setUserName(rs.getString(&quot;user_name&quot;));</span><br><span class="line">               g.setId(rs.getInt(&quot;id&quot;));</span><br><span class="line">               g.setAge(rs.getInt(&quot;age&quot;));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (SQLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       return g;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h3><p><strong>控制层是用来接受视图层的操作，在根据视图层的操作调用模型层中的方法修改数据库，模型层在把修改过后的数据通知控制层，控制层在把结果更新给视图层。在MVC架构中控制层起到一个桥梁作用，连接着视图层与模型层。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   // 创建Dao层对象</span><br><span class="line">      GoddessDao gd = new GoddessDao();</span><br><span class="line">      // 创建一个List泛型为Map,每一个Map就是一个查询条件，Map中存放需要查询的字段、条件、字段等于的值</span><br><span class="line">      List&lt;Map&lt;String , Object&gt;&gt; parameters = new ArrayList&lt;&gt;();</span><br><span class="line">      // 添加查询条件，Map中的Value值可以用对象的get方法获取</span><br><span class="line">      Map&lt;String , Object&gt; parameter = new HashMap&lt;&gt;();</span><br><span class="line">      parameter.put(&quot;name&quot;,&quot;birthday&quot;);</span><br><span class="line">      parameter.put(&quot;relation&quot;,&quot;LIKE&quot;);</span><br><span class="line">      parameter.put(&quot;value&quot;,&quot;%12%&quot;);</span><br><span class="line">      Map&lt;String , Object&gt; parameter2 = new HashMap&lt;&gt;();</span><br><span class="line">      parameter2.put(&quot;name&quot;,&quot;mobile&quot;);</span><br><span class="line">      parameter2.put(&quot;relation&quot;,&quot;LIKE&quot;);</span><br><span class="line">      parameter2.put(&quot;value&quot;,&quot;%139%&quot;);</span><br><span class="line">// 往集合中添加对象</span><br><span class="line">      parameters.add(parameter);</span><br><span class="line">      parameters.add(parameter2);</span><br><span class="line">      // 调用Dao层的查询方法</span><br><span class="line">      Goddess g = gd.getGoddess(parameters);</span><br><span class="line">      System.out.println(g);</span><br></pre></td></tr></table></figure>
<h3 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h3><p><strong>视图层是用来展示数据及传递用户操作的</strong></p>
<h2 id="JDBC各种连接方式的对比"><a href="#JDBC各种连接方式的对比" class="headerlink" title="JDBC各种连接方式的对比"></a>JDBC各种连接方式的对比</h2><ol>
<li>JDBC+ODBC桥的方式：需要数据库的ODBC驱动，只适用于微软系统</li>
<li>JDBC+厂商API的形式：厂商API一般使用C编写</li>
<li>JDBC+厂商Database ConnetionServer+DateBase的形式：在java与数据库之间架起了一台专门用于与数据库连接的服务器。</li>
<li>JDBC+数据库的连接方式：这种方式使应用程序与数据库分开，只需要关心内部逻辑的实现，不需要注重数据库连接的具体实现。所以效率较高，推荐使用这种方法</li>
</ol>
<h1 id="java-WEB知识"><a href="#java-WEB知识" class="headerlink" title="java WEB知识"></a>java WEB知识</h1><p><strong>WEB应用程序是一种通过浏览器与互联网即可访问的应用程序。软件开发领域的三大方向，分别是桌面应用程序(CS架构)与WEB应用程序(BS架构)与嵌入式应用程序(手机端)。静态网页中的内容是固定的，动态网页中的内容通过程序动态显示、自动更新</strong></p>
<h2 id="Tomcat服务器"><a href="#Tomcat服务器" class="headerlink" title="Tomcat服务器"></a>Tomcat服务器</h2><p><strong>Tomcat是一个开源的WEB服务器，也是一个jsp与servlet容器，Tomcat只需要解压缩就安装成了，执行Tomact安装目录下的bin目录下的startup.bat并浏览localhost:8080即可，修改Tomcat默认端口号需要修改conf下的server.xml文件中的&lt;Connector port=”端口号”即可。也可以在里面加URLEncoding=”编码”来修改解析URL时的编码。Tomcat在解析提交的数据时，默认使用ISO-8859-1编码。表单提交的数据可以通过request对象修改编码，而url可以通过修改server.xml文件。Tomcat中session默认超市时间为30分钟，可以通过修改web.xml文件修改</strong></p>
<p>Tomcat服务器目录结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bin  启动和停止Tomcat服务的命令文件</span><br><span class="line">conf  配置文件</span><br><span class="line">lib  所需的各种jar文件</span><br><span class="line">logs  日志文件</span><br><span class="line">temp  运行时存放临时文件</span><br><span class="line">webapps   发布时，默认会将web应用的文件发布到此目录</span><br><span class="line">work   存放jsp生成的servlet</span><br></pre></td></tr></table></figure></p>
<p><strong>javaWEB中的WEB-INF目录是javaWEB应用的安全目录，也就是客户端无法访问，只能由服务器端访问的目录。其中web.xml为项目配置文件，当修改web.xml时应重启Tomcat服务器。classes文件夹存放编译生成的字节码文件。lib文件夹存放依赖jar包</strong></p>
<p>web.xml配置项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;welcome-file-list&gt;  配置欢迎页面列表，可以有多个欢迎页面</span><br><span class="line">&lt;welcome-file&gt;   与欢迎页面列表配合使用，配置欢迎页面，参数以/开始，必须在欢迎页面列表标签中</span><br><span class="line">&lt;session-config&gt;   设置session</span><br><span class="line">&lt;session-timeout&gt;  设置session的超时时间必须在sessionconfig标签中。单位为分钟</span><br></pre></td></tr></table></figure></p>
<h2 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h2><p><strong>jsp是一个简化的servlet，实现了在java当中使用html标签，是一种动态网页技术，jsp与servlet是在服务器端执行的。</strong></p>
<h3 id="jsp基础语法"><a href="#jsp基础语法" class="headerlink" title="jsp基础语法"></a>jsp基础语法</h3><p><strong>jsp页面由静态内容、指令、表达式、脚本、声明、注释构成,jsp页面可以使用html的注释<!--内容-->java的注释以及jsp自己的注释&lt;%–内容–%&gt;,其中除html注释在客户端可见之外，其余两张注释在客户端都不可见,x需要注意的是java注释需要写在&lt;% %&gt;中</strong></p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><strong>指令元素一共有3种，分别是page指令、include指令及taglib指令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">page指令  通常位于jsp页面顶端、同一个页面可以有多个page指令</span><br><span class="line"></span><br><span class="line">include指令   将一个外部文件嵌入到当前jsp页面中，同时解析这个页面的jsp语句，与include指令想同的还有include动作</span><br><span class="line"></span><br><span class="line">taglib指令   使用标签库定义新的自定义标签，在jsp页面中启用定制行为</span><br></pre></td></tr></table></figure></p>
<p>page指令语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page 属性1=&quot;属性值&quot; 属性2=&quot;属性值2&quot; ..  %&gt;   page常用属性：language:指定页面使用的脚本语言、import:引用脚本语言使用到的类文件、contentType:指定页面编码格式、ErrorPage：指定处理异常的页面</span><br></pre></td></tr></table></figure></p>
<p>include指令语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ include file=&quot;URL&quot;%&gt; file属性是包含的页面</span><br></pre></td></tr></table></figure></p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p><strong>脚本是指在jsp页面执行java代码，写在&lt;% %&gt;中的java代码即是脚本</strong></p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><strong>声明是指jsp页面中定义的变量或方法,定义方法时需要定义返回值类型，声明变量需要把变量放在第一行，负责表达式不能识别</strong>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%! java代码 %&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p><strong>表达式既是在jsp页面执行的表达式，表达式不能以分号结束</strong>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%=表达式 %&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="jsp页面的声明周期"><a href="#jsp页面的声明周期" class="headerlink" title="jsp页面的声明周期"></a>jsp页面的声明周期</h3><p><strong>当用户发送一个请求时，服务器会先判断是否是第一次请求这个资源，如果是第一次，jsp引擎会把该jsp文件转换成为一个servlet，生成字节码文件并执行jspInit()方法。如果不是第一次请求，会直接访问生成的字节码文件。最后解析执行jspService()方法处理用户的请求。对每一个请求，jsp引擎都会创建一个新线程来处理。当jsp页面发生改变时，jsp引擎会重新编译jsp文件</strong></p>
<h3 id="jsp内置对象"><a href="#jsp内置对象" class="headerlink" title="jsp内置对象"></a>jsp内置对象</h3><p><strong>jsp内置对象是WEB容器创建的一组对象，不使用new关键字就可使用的对象。jsp九大内置对象分别是：out、request、response、session、application、page、pageContext、exception、config</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">out  </span><br><span class="line">request</span><br><span class="line">response</span><br><span class="line">session</span><br><span class="line">application</span><br><span class="line">page</span><br><span class="line">pageContext</span><br><span class="line">exception</span><br><span class="line">config</span><br></pre></td></tr></table></figure></p>
<h4 id="out对象"><a href="#out对象" class="headerlink" title="out对象"></a>out对象</h4><p><strong>out对象用来向客户端输出内容，是jspWriter类的实例，out对象也可以输出html标签，out对象默认带有缓冲区且自动刷新</strong><br>常用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">println()  向客户端打印字符串</span><br><span class="line">clear()  清除缓冲区内容，如果在flush方法之后调用会有异常</span><br><span class="line">clearBuffer()  清除缓冲区，不会抛出异常</span><br><span class="line">flush()   刷新缓冲区</span><br><span class="line">getBufferSize()  获取缓冲区字节大小，如没有缓冲区则返回0</span><br><span class="line">getRemaining()  获取缓冲区剩余字节</span><br><span class="line">isAutoFlush()  是否自动刷新</span><br><span class="line">close()  关闭</span><br></pre></td></tr></table></figure></p>
<h4 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h4><p><strong>客户端的请求被封装在request对象中，它是HTTPServletRequest类的实例。request对象拥有请求域，在完成客户端的请求之前，该对象一直有效</strong></p>
<p>常用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getParameter(name)  获取名字为name的参数</span><br><span class="line">getParameterValues(name)  获取名字为name的所有属性</span><br><span class="line">setAttribute(name,value)  设置请求中的属性，如果没有对应的属性，则新增</span><br><span class="line">getAttribute(name)  根据name获取请求中的属性</span><br><span class="line">getContentType()  获取请求端的MIME类型</span><br><span class="line">getProtocol()	获取请求所用的协议类型及版本号</span><br><span class="line">getServerName()  获取接受请求的服务器主机名</span><br><span class="line">setCharacterEncoding(en)  设置接受请求的编码为en，当接受的请求有乱码时，可以使用这个方法把编码设置为跟提交时的编码一致</span><br><span class="line">getServerPort()	获取服务器端口号</span><br><span class="line">getCharacterEncoding()	 获取字符编码</span><br><span class="line">getContentLength()  获取请求体的大小</span><br><span class="line">getRemoteAddr()  获取发送请求的客户端的IP地址</span><br><span class="line">getRealPath(path)  根据path获取虚拟路径的真实路径</span><br><span class="line">getContextPath()  获取上下文路径</span><br><span class="line">getRequestDispatcher(location).forward(request,response)  请求转发到location</span><br></pre></td></tr></table></figure></p>
<h4 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h4><p><strong>response对象是用来相应请求的，它是HTTPServletReponse类的实例，response对象具有页面作用域，当访问一个页面时，该页面的response对象只能对这次访问有效，其他页面的response对象对当前页面无效。</strong></p>
<p>常用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getCharacterEncoding()  获取相应的编码格式</span><br><span class="line">setContextType(type)  设置响应的MIME类型</span><br><span class="line">getWrite()  获取打印流对象，用来写响应信息，打印流对象输出提前与out对象输出</span><br><span class="line">sendRedirect(location)  把请求重定向到location</span><br></pre></td></tr></table></figure></p>
<p><strong>请求重定向是客户端行为，等同于两次请求，前一次的请求对象不会保存。请求转发是服务器行为，是一次请求，前一次的请求对象会保存</strong></p>
<h4 id="session对象"><a href="#session对象" class="headerlink" title="session对象"></a>session对象</h4><p><strong>session表示客户端与服务器的一次会话，session是一个特定的时间概念，指的是用户在浏览网站时，从进入网站到关闭浏览器这段时间，session保存在服务器内存中。session对象在打开第一个页面时自动创建，完成会话管理。session对象是保存用户状态的机制</strong></p>
<p>常用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getCreationTime()  获取session对象的创建时间</span><br><span class="line">getId()  获取session对象的唯一ID</span><br><span class="line">setAttribute(name,value)  设置session中的属性，如果没有name对应的属性则创建</span><br><span class="line">getAttribute(name)	根据name获取属性</span><br><span class="line">getValueNames()	获取session中的所有属性</span><br><span class="line">getMaxInactiveInterval()	获取两次请求间隔多久session自动取消</span><br><span class="line">setMaxInactiveInterval()   设置两次请求间隔时间多久session自动取消</span><br><span class="line">invalidate()  销毁session</span><br></pre></td></tr></table></figure></p>
<p><strong>当客户端第一次访问服务器的时候，服务器会为当前会话创建一个SessionId，每当客户端向服务器发送请求时，都会讲sessionId带进去，服务器会对此sessionId进行校验。在创建session对象之后，通过这个页面打开的每一个页面与这个页面相关资源都属于同一个会话，有着同一个sessionId。当页面全部关闭时，在重新打开这个页面就会创建新的session，这时旧的session还存在服务器端。session的销毁可以通过调用session对象的invalidate方法、session过期、服务器重启这三种方法。</strong></p>
<h4 id="application对象"><a href="#application对象" class="headerlink" title="application对象"></a>application对象</h4><p><strong>application对象实现了用户间数据的共享，可以存放全局变量，application对象创建于服务器的启动，服务器停止时application对象会销毁</strong><br>常用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setAttribute(name,value)  设置属性，如果没有对象的属性，则创建</span><br><span class="line">getAttribute(name)  获取name对象的属性值</span><br><span class="line">getAttributeNames()  获取application对象中的所有属性名，返回的是一个枚举类</span><br><span class="line">getServerInfo()  获取jsp引擎名及版本号</span><br></pre></td></tr></table></figure></p>
<h4 id="page对象"><a href="#page对象" class="headerlink" title="page对象"></a>page对象</h4><p><strong>page对象就是当前页面本身</strong></p>
<p>常用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getClass()  获取当前page的类</span><br><span class="line">hashCode()	获取当前page的hash码</span><br><span class="line">equals(obj)	使当前page与另一个obj比较是否相等</span><br><span class="line">copy(obj)	把当前page拷贝到目标obj中</span><br><span class="line">colne()		克隆当前page</span><br><span class="line">toString()	把此page对象转化为String类的对象</span><br><span class="line">notify()	唤醒一个等待的线程</span><br><span class="line">notifyAll()	唤醒所有等待的线程</span><br><span class="line">wait(timeout)	使一个线程处于等待直到timeout结束或被唤醒</span><br><span class="line">wait()		使一个线程处于等待直到被唤醒</span><br></pre></td></tr></table></figure></p>
<h4 id="pageContext对象"><a href="#pageContext对象" class="headerlink" title="pageContext对象"></a>pageContext对象</h4><p><strong>pageContext对象提供了对页面所有的对象及名字空间的访问，也可以访问其他的内置对象</strong></p>
<p>常用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getOut()  获取当前客户端使用的输出流</span><br><span class="line">getSession()	获取当前页面的session</span><br><span class="line">getPage()	获取当前页面的page对象</span><br><span class="line">getRequest()	获取当前页面的request对象</span><br><span class="line">getResponse()	获当前页面的response对象</span><br><span class="line">setAttribute(name,value)	设置属性值，如没有对应属性，则创建</span><br><span class="line">getAttribute(name，scope)	在指定范围内取属性值</span><br><span class="line">getAttributeScope(name)		获取属性的范围值</span><br><span class="line">forward(relativeURL)	使当前页面转发到另一页面</span><br><span class="line">include(relativeURL)	在当前位置包含另一页面</span><br></pre></td></tr></table></figure></p>
<h4 id="Config对象"><a href="#Config对象" class="headerlink" title="Config对象"></a>Config对象</h4><p><strong>config对象是在一个servlet初始化时，jsp引擎向它传递信息用的。</strong></p>
<p>常用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getServletContext()   获取服务器相关信息的ServletContext对象</span><br><span class="line">getInitParameter(name)   根据name获取对应的初始化属性值</span><br><span class="line">getInitParameterNames    获取Servlet初始化所需要的所有参数的枚举</span><br></pre></td></tr></table></figure></p>
<h4 id="Exception对象"><a href="#Exception对象" class="headerlink" title="Exception对象"></a>Exception对象</h4><p><strong>Exception对象是一个异常对象，当一个页面在运行过程中发生了异常就会产生这个对象，如果一个页面需要应用此对象，必须把isErrorPage设为true</strong></p>
<p>常用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getMessage()		获取描述异常的信息</span><br><span class="line">toString()			获取关于异常的简短描述</span><br><span class="line">printStackTrace()	显示异常及栈轨迹</span><br><span class="line">FillInStacktrace()  重写异常的执行栈轨迹</span><br></pre></td></tr></table></figure></p>
<h3 id="javaBean"><a href="#javaBean" class="headerlink" title="javaBean"></a>javaBean</h3><p><strong>javaBean就是符合某种特定规范的java类，符合javaBean的设计原则：公有类、无参共有构造方法、属性私有、属性提供get与set方法的就称为javaBeans</strong></p>
<h3 id="jsp动作元素"><a href="#jsp动作元素" class="headerlink" title="jsp动作元素"></a>jsp动作元素</h3><p><strong>jsp动作元素为请求处理阶段提供信息，动作元素遵循xml元素的语法。</strong></p>
<h4 id="与javaBean有关的动作元素"><a href="#与javaBean有关的动作元素" class="headerlink" title="与javaBean有关的动作元素"></a>与javaBean有关的动作元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=&quot;标识符&quot; class=&quot;类路径与类名&quot; scope=&quot;作用范围&quot; /&gt;</span><br><span class="line">&lt;jsp:setProperty name=&quot;useBeanId&quot; property=&quot;*&quot;&gt;  跟表单相关联，匹配所有表单name属性与实体类的属性名相同的</span><br><span class="line">&lt;jsp:setProperty name=&quot;useBeanId&quot; property=&quot;属性名&quot;&gt;  跟表单相关联，匹配表单中属性名相同的属性</span><br><span class="line">&lt;jsp:setProperty name=&quot;useBeanId&quot; property=&quot;属性名&quot; value=&quot;属性值&quot;&gt;  手工设置属性</span><br><span class="line">&lt;jsp:setProperty name=&quot;useBeanId&quot; property=&quot;属性名&quot; param=&quot;request对象中的参数名&quot;&gt;  与request关联，匹配param并赋值给property</span><br><span class="line">&lt;jsp:getProperty name=&quot;javaBean实例&quot; property=&quot;属性名&quot;&gt;  获取制定属性名的属性值</span><br></pre></td></tr></table></figure>
<p><strong>javaBean动作的四个作用范围分别是page(仅在当前页面有效)、request(可以通过request.getAttribute获取此对象，也可以通过jsp动作元素获取)、session(可以通过session的getAttribute方法获取)、application(可以通过application的getAttribute方法获取)</strong></p>
<h4 id="include动作"><a href="#include动作" class="headerlink" title="include动作"></a>include动作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=&quot;URL&quot; flush=&quot;true|false&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p><strong>flush默认为 false 在同一个 JSP 中，如果不断使用动作 include 自己（源文件），在逻辑上会形成死循环。而当把flush 属性赋为真值时，在缓存累积了一定数据时，服务器会先提供一部分数据给浏览器，并等待后续内容。由此可以得出结论，在简单页面中，该属性不纳入考虑，而在页面包含大量数据时，为缩短客户端延迟，可将一部分内容先行输出。</strong></p>
<p><strong>include指令实际上包含的是页面的实际内容也就是源代码，而include动作包含的是页面的输出结果。也就是说include指令相较于动作中编译时间较慢，而执行时间较快。且指令能使用与修改被包含页面的变量等。动作在请求期间被执行，而include指令在编译期页面间被执行。在页面经常变化时适合使用动作，负责使用指令</strong></p>
<h4 id="forward动作"><a href="#forward动作" class="headerlink" title="forward动作"></a>forward动作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=&quot;URL&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p><strong>forward动作等同于request对象的转发指令，中文乱码可以使用request.setCharacterEncoding()修改为提交页面的编码解决</strong></p>
<h4 id="param动作"><a href="#param动作" class="headerlink" title="param动作"></a>param动作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=&quot;URL&quot;&gt;</span><br><span class="line">	&lt;jsp:param name=&quot;属性名&quot; value=&quot;属性值&quot; /&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure>
<p><strong>param动作常常与forward动作一起使用，作为它的子标签使用，param动作会覆盖原有的同名参数</strong></p>
<h3 id="jsp状态管理"><a href="#jsp状态管理" class="headerlink" title="jsp状态管理"></a>jsp状态管理</h3><p><strong>HTTP的无状态性是指当客户端发送请求时，服务器都会当做第一次发送请求来处理，不会保存客户端上次的状态，而session与Cookie就是保存状态的两种方法。cookie是服务器保存在客户端的一系列文本信息，它可以对特定对象保持追踪，但是因为保存在客户端，所有可能有泄露风险</strong></p>
<p>jsp中创建于使用cookie及cookie常用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Cookie newCookie = new Cookie(key,value)  创建cookie</span><br><span class="line">response.addCookie(newCookie)  写入Cookie</span><br><span class="line">Cookie[] cookies = request.getCookies()  读取cookie</span><br><span class="line">遍历cookies根据key获取制定的value</span><br><span class="line"></span><br><span class="line">setMaxAge(time)		设置cookie的有效期，单位为秒</span><br><span class="line">setValue(value)		对cookie赋值</span><br><span class="line">getName()			获取cookie名字</span><br><span class="line">getValue()			获取cookie值</span><br><span class="line">getMaxAge()			获取cookie的有效时间</span><br></pre></td></tr></table></figure></p>
<p><strong>cookie中如果要存放中文字符，需要使用URLEncoder类与URLDecoder类解决。session保存在服务器，cookie保存在客户端，session用来保存重要的信息，cookie用来保存不重要的信息。session可以保存任意类型的对象，cookie只能保存字符串类型的对象</strong></p>
<p><strong>使用jsp+cookie实现浏览记录：</strong></p>
<p>首页：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">	&lt;%@ page import=&quot;entity.dao.itemsDao&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;entity.Items&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Administrator</span><br><span class="line">  Date: 2019/10/14 0014</span><br><span class="line">  Time: 20:37</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        #content&#123;</span><br><span class="line">            text-align:center</span><br><span class="line">        &#125;</span><br><span class="line">        .commodity&#123;</span><br><span class="line">            width:150px;</span><br><span class="line">            display:inline-block;</span><br><span class="line">            margin:20px;</span><br><span class="line">        &#125;</span><br><span class="line">        img&#123;</span><br><span class="line">            width:150px;</span><br><span class="line">            height:150px;</span><br><span class="line">        &#125;</span><br><span class="line">        span&#123;</span><br><span class="line">            display: block;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;商品展示&lt;/h1&gt;</span><br><span class="line">&lt;div id=&quot;content&quot; &gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        itemsDao id = new itemsDao();</span><br><span class="line">        ArrayList&lt;Items&gt; items = id.getItems();</span><br><span class="line">        if (items != null &amp;&amp; items.size() &gt; 0)&#123;</span><br><span class="line">            for (int i = 0; i&lt;items.size(); i++)&#123;</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        Items item = items.get(i);</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;div class=&quot;commodity&quot;&gt;</span><br><span class="line">        &lt;img src=&quot;img\&lt;%=item.getPicture()%&gt;&quot; /&gt;</span><br><span class="line">        &lt;a href=&quot;details.jsp?id=&lt;%=item.getId()%&gt;&quot;&gt;&lt;%=item.getName()%&gt;&lt;/a&gt;</span><br><span class="line">        &lt;span&gt;产地：&lt;%=item.getCity()%&gt;&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;价格：￥ &lt;%=item.getPrice()%&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>商品详情页：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">	&lt;%@ page import=&quot;entity.dao.itemsDao&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;entity.Items&quot; %&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;</span><br><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: Administrator</span><br><span class="line">  Date: 2019/10/28 0028</span><br><span class="line">  Time: 16:55</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"></span><br><span class="line">        #content &#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #details &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            margin-right: 125px;</span><br><span class="line">            position: relative;</span><br><span class="line">            bottom: 75px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #details img &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #history &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            margin-left: 300px;</span><br><span class="line">            background-color: darkgrey;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #history img &#123;</span><br><span class="line">            width: 120px;</span><br><span class="line">            height: 120px;</span><br><span class="line">            border: 1px solid red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #history div &#123;</span><br><span class="line">            margin: 10px 100px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;商品详情&lt;/h1&gt;</span><br><span class="line">&lt;div id=&quot;content&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;details&quot;&gt;</span><br><span class="line">        &lt;%</span><br><span class="line">            Integer id = Integer.parseInt(request.getParameter(&quot;id&quot;));</span><br><span class="line">            itemsDao dao = new itemsDao();</span><br><span class="line">            Items item = dao.getItem(id);</span><br><span class="line">            if (item != null) &#123;</span><br><span class="line">        %&gt;</span><br><span class="line">        &lt;img src=&quot;img\&lt;%=item.getPicture()%&gt;&quot;/&gt;</span><br><span class="line">        &lt;div style=&quot;float:right;&quot;&gt;</span><br><span class="line">            &lt;h3&gt;&lt;%=item.getName()%&gt;</span><br><span class="line">            &lt;/h3&gt;</span><br><span class="line">            &lt;div&gt;产地：&lt;%=item.getCity()%&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div style=&quot;margin-top:80px;&quot;&gt;价格：￥ &lt;%=item.getPrice()%&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;%</span><br><span class="line">            &#125;</span><br><span class="line">        %&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;history&quot;&gt;</span><br><span class="line">        &lt;h3&gt;您浏览过的商品&lt;/h3&gt;</span><br><span class="line">        &lt;%</span><br><span class="line">            Cookie[] cookies = request.getCookies();</span><br><span class="line">            String itemIDs = &quot;&quot;;</span><br><span class="line">            for (Cookie cookie : cookies) &#123;</span><br><span class="line">                if (&quot;itemId&quot;.equals(cookie.getName())) &#123;</span><br><span class="line">                    itemIDs += cookie.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 只会保存一个商品历史记录，因为每次进入这个页面都会新创建一个itemID；解决办法为先取出来cookie在保存cookie</span><br><span class="line">            if (itemIDs != null) &#123;</span><br><span class="line">                String[] itemIds = itemIDs.toString().split(&quot;,&quot;);</span><br><span class="line">                int j = 0;</span><br><span class="line">                if (itemIds != null &amp;&amp; itemIds.length &gt; 0) &#123;</span><br><span class="line">                    for (int i = itemIds.length; i &gt;= 0; i--) &#123;</span><br><span class="line">                        if (j &gt;= 5) &#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        Items item1 = dao.getItem(Integer.parseInt(itemIds[i - 1]));</span><br><span class="line">                        j++;</span><br><span class="line">        %&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src=&quot;img\&lt;%=item1.getPicture()%&gt;&quot;/&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;&lt;a href=&quot;details.jsp?id=&lt;%=item1.getId()%&gt;&quot;&gt;&lt;%=item1.getName()%&gt;</span><br><span class="line">        &lt;/a&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;产地：&lt;%=item1.getCity()%&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div&gt;价格：￥ &lt;%=item1.getPrice()%&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;%</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            itemIDs += request.getParameter(&quot;id&quot;) + &quot;,&quot;;</span><br><span class="line">            Cookie cookie = new Cookie(&quot;itemId&quot;, itemIDs.toString());</span><br><span class="line">            response.addCookie(cookie);</span><br><span class="line">        %&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="java-WEB过滤器"><a href="#java-WEB过滤器" class="headerlink" title="java WEB过滤器"></a>java WEB过滤器</h2><p><strong>要使用过滤器必须导入servlet-api.jar这个jar包</strong></p>
<p><strong>过滤器包括过滤源、过滤规则、过滤结果，在WEB浏览器中过滤器是一个服务器端的组件，它可以用来截取用户端的请求与相应信息，并对这些信息过滤</strong></p>
<p><strong>过滤器是在WEB容器启动时加载，当用户发送请求时会首先经过过滤器，过滤器判断是否发送给WEN资源，WEB资源在返回给过滤器，在响应给用户</strong></p>
<p><strong>过滤器的生命周期分为实例化(WEB容器启动时加载)、初始化(启动成功调用过滤器的init()方法进行读取web.xml中的过滤器参数进行初始化)、过滤(调用doFilter()方法)及销毁(在WEB容器关闭时调用destroy()方法)四个阶段</strong>  </p>
<p><strong>创建过滤器时要让这个类实现javax.servlet包下的Filter接口，init方法通过参数过去web.xml中的设置。doFilter方法完成实际的过滤工作,其中，filterChain参数的doFilter方法是放行方法。doFilter方法执行顺序为处理请求代码、放行、处理返回资源代码</strong></p>
<p><strong>过滤器只能改变用户请求的WEB资源，不能直接返回数据</strong></p>
<p><strong>当有多个过滤器的url指向同一个时，就会形成过滤器链，这时过滤器的执行顺序会根据WEB.xml中过滤器定义的先后顺序执行</strong></p>
<p><strong>过滤器分为REQUEST(默认，当用户直接访问时，WEB容器会调用过滤器)、FORWARD(当目标资源时通过转发访问时，将调用该过滤器)、INCLUDE(当目标通过被包含访问时调用该访问器)、ERROR(当访问错误提示页面时会调用该过滤器，访问错误提示页面时，REQUEST类型的过滤器不会调用)、ASYNC(Sevlet3.0加入的分类，当访问资源是被异步处理时会调用该过滤器)</strong></p>
<p><strong>@WebFilter 注解用于将一个类声明为过滤器，在部署时会根据具体的属性配置将对应的类部署为过滤器</strong></p>
<p><strong>@WebFilter常用属性有：filterName(filter名字)、value(请求的URL,等价于urlPatterns，两者不能同时使用)、urlPatterns(请求的URL)、servletNames(指定过滤器要应用与那些Servlet，取值为filter名字)、dispatcherType(等同于dispatcher，过滤器的种类)、initParams(初始化参数，等同于init-param)、asyncSupported(声明过滤器是否支持异步操作，等同于async-supported)、description(描述信息，等同于description)、displayName(该过滤器的显示名)</strong></p>
<p>web.xml中有关过滤器的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;  //过滤器，可以有多个，filter名字必须不相同</span><br><span class="line">	&lt;filter-name&gt;filter名字&lt;/&gt;filter-name&gt;</span><br><span class="line">	&lt;filter-class&gt;filter完整的类名称&lt;/filter-class&gt;</span><br><span class="line">	&lt;init-param&gt; //初始化参数，可以有多个init</span><br><span class="line">		&lt;description&gt;描述信息&lt;/description&gt;</span><br><span class="line">		&lt;param-name&gt;参数名字&lt;/param-name&gt;</span><br><span class="line">		&lt;param-value&gt;参数值&lt;/param-value&gt;</span><br><span class="line">	&lt;init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt; //过滤器映射，可以有多个</span><br><span class="line">	&lt;filter-name&gt;filter名字，与filter标签中的一致&lt;/filter-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;请求的URL,当请求的URL匹配时将使用过滤器&lt;/url-pattern&gt;</span><br><span class="line">	&lt;dispatcher&gt;REQUEST|INCLUDE|FORWARD|ERROR|ASYNC  可以有多个，默认为REQUEST&lt;/dispatcher&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>可以通过配置WEB.xml中的初始化参数来设置跳过过滤的页面</strong></p>
<p>使用过滤器实现登录校验与编码转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">	package filter_demo;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import javax.servlet.annotation.WebInitParam;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@WebFilter(filterName = &quot;LoginFilter&quot;, value = &#123;&quot;/*&quot;&#125;, dispatcherTypes = &#123;DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE&#125;,</span><br><span class="line">            initParams = &#123;</span><br><span class="line">                @WebInitParam(name = &quot;noLoginFilter&quot;, value = &quot;loginServlet;index.jsp;fail.jsp&quot;),</span><br><span class="line">                    @WebInitParam(name= &quot;charset&quot;, value=&quot;UTF-8&quot;)</span><br><span class="line">            &#125;)</span><br><span class="line">public class LoginFilter implements Filter &#123;</span><br><span class="line">    private FilterConfig config;</span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse) resp;</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        // 以初始化参数中指定的字符集来解析客户端发送的数据</span><br><span class="line">        request.setCharacterEncoding(config.getInitParameter(&quot;charset&quot;));</span><br><span class="line">        // 根据URL放行特定界面</span><br><span class="line">        if (request.getRequestURI().indexOf(&quot;index.jsp&quot;) != -1 || request.getRequestURI().indexOf(&quot;loginServlet&quot;) != -1)&#123;</span><br><span class="line">            chain.doFilter(req, resp);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 根据初始化参数放行特定界面</span><br><span class="line">        String noLoginPaths = config.getInitParameter(&quot;noLoginFilter&quot;);</span><br><span class="line">        if (noLoginPaths != null)&#123;</span><br><span class="line">            String[] paths = noLoginPaths.split(&quot;;&quot;);</span><br><span class="line">            for (String path : paths)&#123;</span><br><span class="line">                if (path == null || path.equals(&quot;&quot;)) continue;</span><br><span class="line">                if (request.getRequestURI().indexOf(path) != -1)&#123;</span><br><span class="line">                    chain.doFilter(req, resp);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;admin&quot;.equals(session.getAttribute(&quot;username&quot;)))</span><br><span class="line">            chain.doFilter(req, resp);</span><br><span class="line">        else</span><br><span class="line">            response.sendRedirect(request.getContextPath() + &quot;/index.jsp&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init(FilterConfig config) throws ServletException &#123;</span><br><span class="line">        this.config = config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p><strong>Servlet是在服务器上运行的小程序，Servlet就是一个类</strong></p>
<p><strong>Tomcat的容器等级分为四个，Servlet的容器负责管理Context容器，一个Context对应一个WEB工程。Tomcatg容器级别从大到小分别是Tomcat容器、Container容器、Engine容器(引擎容器)、HOST容器(主机容器)、Servlet容器、Context容器</strong></p>
<p><strong>Servlet继承HttpServlet并重写doGet与doPost方法，并且在WEB.xml中注册即可</strong></p>
<p>WEB.xml中配置Servlet：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;servlet名字&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;Servlet路径&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;servlet名字&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;界面请求的路径&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>当客户端发送请求时，服务器端会根据提交的路径在WEB.xml寻找对应的servlet-mapping，根据servlet-mapping找到对应的servlet。在根据提交的请求方式选择执行那个方法</strong></p>
<p><strong>Servlet的生命周期分为装载阶段(当用户请求时判断这个servlet是否存在如果不存在调用构造方法创建实例且初始化)、初始化阶段、(调用init方法进行初始化)、运行阶段(调用service方法判断请求方式并调用对应的方法)、销毁阶段(服务器关闭时调用destory方法销毁)</strong></p>
<p><strong>Servlet容器加载Servlet的三种情况：</strong></p>
<ul>
<li>Servlet容器启动时自动装载Servlet，通过在WEB.xml中的servlet标签之间添加loadon-startup标签实现,其中数字越小优先级越高，在启动时就会优先加载：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Servlet&gt;</span><br><span class="line">	&lt;loadon-stratup&gt;1&lt;/loadon-stratup&gt;</span><br><span class="line">&lt;/Servlet&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在Servlet容器启动后，客户端首次向Servlet发送请求时Servlet容器会加载对应的Servlet</p>
</li>
<li><p>在Servlet类文件被重新修改之后，重新加载Servlet</p>
</li>
</ul>
<p><strong>Servlet被装载后，Servlet容器创建一个Servlet实例并调用初始化方法，在Servlet整个生命周期内，初始化方法只会调用一次</strong></p>
<p><strong>JSP内置对象与Servlet的对应关系：</strong></p>
<table>
<thead>
<tr>
<th>JSP对象</th>
<th>Servlet中怎样获得 </th>
</tr>
</thead>
<tbody>
<tr>
<td>out</td>
<td>response.getWrite</td>
<td></td>
</tr>
<tr>
<td>request</td>
<td>service中的request参数</td>
<td></td>
</tr>
<tr>
<td>reponse</td>
<td>service中的reponse参数</td>
<td></td>
</tr>
<tr>
<td>session</td>
<td>request.getSession方法</td>
<td></td>
</tr>
<tr>
<td>application</td>
<td>getServletContext()方法</td>
<td></td>
</tr>
<tr>
<td>exception</td>
<td>Throwable</td>
<td></td>
</tr>
<tr>
<td>page</td>
<td>this</td>
<td></td>
</tr>
<tr>
<td>pageContext</td>
<td>PageContext</td>
<td></td>
</tr>
<tr>
<td>config</td>
<td>getServletConfig方法</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Servlet中获取请求中的字符串参数可以通过reques.getParameter方法，获取复选框中的参数可以通过request.getParameterValues方法</strong></p>
<p><strong>Servlet中相对路径指相对于文件当前位置进行访问，绝对路径指相对于项目根目录进行访问。使用相对路径时第一个/表示的是WEB容器根目录，使用绝对路径时可以使用request.getContextPath获取项目根目录。使用重定向时必须使用绝对路径跳转</strong></p>
<p><strong>在WEB.xml中配置Servlet时，可以配置一些初始化参数，在Servlet中可以在init方法中通过ServletConfig接口提供的方法来获取初始化参数</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/13/java中的面向对象/" rel="next" title="java中的面向对象">
                <i class="fa fa-chevron-left"></i> java中的面向对象
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/02/学习时遇到的问题/" rel="prev" title="学习时遇到的问题">
                学习时遇到的问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">冰断秋</p>
              <p class="site-description motion-element" itemprop="description">希望你每一天都对得起自己的梦想</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
		
      </section>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=35288859&auto=1&height=66"></iframe>
      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA基础知识"><span class="nav-number">1.</span> <span class="nav-text">JAVA基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理"><span class="nav-number">1.1.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">1.2.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间和日期的处理"><span class="nav-number">1.3.</span> <span class="nav-text">时间和日期的处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math类的常用方法"><span class="nav-number">1.4.</span> <span class="nav-text">Math类的常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合"><span class="nav-number">1.5.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中的进制"><span class="nav-number">1.6.</span> <span class="nav-text">java中的进制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io流"><span class="nav-number">1.7.</span> <span class="nav-text">io流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编码"><span class="nav-number">1.7.1.</span> <span class="nav-text">编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File类"><span class="nav-number">1.7.2.</span> <span class="nav-text">File类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常用方法："><span class="nav-number">1.7.2.1.</span> <span class="nav-text">常用方法：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RandomAccessFile类"><span class="nav-number">1.7.3.</span> <span class="nav-text">RandomAccessFile类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节流与字符流"><span class="nav-number">1.7.4.</span> <span class="nav-text">字节流与字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字节流"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">字节流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#字节输入流"><span class="nav-number">1.7.4.1.1.</span> <span class="nav-text">字节输入流</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#InputStream的读方法："><span class="nav-number">1.7.4.1.1.1.</span> <span class="nav-text">InputStream的读方法：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#FileInputStream"><span class="nav-number">1.7.4.1.1.2.</span> <span class="nav-text">FileInputStream</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字节输出流"><span class="nav-number">1.7.4.1.2.</span> <span class="nav-text">字节输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#OutputStream的写方法："><span class="nav-number">1.7.4.1.2.1.</span> <span class="nav-text">OutputStream的写方法：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#FileOutputStream"><span class="nav-number">1.7.4.1.2.2.</span> <span class="nav-text">FileOutputStream</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用字节流实现复制文件："><span class="nav-number">1.7.4.1.3.</span> <span class="nav-text">使用字节流实现复制文件：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据字节流"><span class="nav-number">1.7.4.1.4.</span> <span class="nav-text">数据字节流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#带缓冲区的字节流"><span class="nav-number">1.7.4.1.5.</span> <span class="nav-text">带缓冲区的字节流</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符流"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#字符流的基本实现"><span class="nav-number">1.7.4.2.1.</span> <span class="nav-text">字符流的基本实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileReade与FileWrited"><span class="nav-number">1.7.4.2.2.</span> <span class="nav-text">FileReade与FileWrited</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符流过滤器"><span class="nav-number">1.7.4.2.3.</span> <span class="nav-text">字符流过滤器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#打印流：PrintWriter"><span class="nav-number">1.7.4.2.4.</span> <span class="nav-text">打印流：PrintWriter</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象序列化"><span class="nav-number">1.8.</span> <span class="nav-text">对象序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#序列化基础"><span class="nav-number">1.8.1.</span> <span class="nav-text">序列化基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序列化中子类父类构造方法"><span class="nav-number">1.8.2.</span> <span class="nav-text">序列化中子类父类构造方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java中的XML"><span class="nav-number">2.</span> <span class="nav-text">Java中的XML</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#XML读取"><span class="nav-number">2.1.</span> <span class="nav-text">XML读取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何在Java中保留xml的结构"><span class="nav-number">2.1.1.</span> <span class="nav-text">如何在Java中保留xml的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用的节点类型及方法的返回值"><span class="nav-number">2.1.2.</span> <span class="nav-text">常用的节点类型及方法的返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM方式解析XML文件"><span class="nav-number">2.1.3.</span> <span class="nav-text">DOM方式解析XML文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SAX解析"><span class="nav-number">2.1.4.</span> <span class="nav-text">SAX解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SAX解析XML文件"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">SAX解析XML文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDOM解析"><span class="nav-number">2.1.5.</span> <span class="nav-text">JDOM解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDOM解析的中文乱码问题"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">JDOM解析的中文乱码问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM4J解析"><span class="nav-number">2.1.6.</span> <span class="nav-text">DOM4J解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四种解析方式的分析以及解析速度对比"><span class="nav-number">2.1.7.</span> <span class="nav-text">四种解析方式的分析以及解析速度对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XML写入"><span class="nav-number">2.2.</span> <span class="nav-text">XML写入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM写入"><span class="nav-number">2.2.1.</span> <span class="nav-text">DOM写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SAX生成XML文件"><span class="nav-number">2.2.2.</span> <span class="nav-text">SAX生成XML文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RSS文件"><span class="nav-number">2.2.3.</span> <span class="nav-text">RSS文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM4J生成rss文件"><span class="nav-number">2.2.4.</span> <span class="nav-text">DOM4J生成rss文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDOM生成XML文件"><span class="nav-number">2.2.5.</span> <span class="nav-text">JDOM生成XML文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成方式的对比"><span class="nav-number">2.2.6.</span> <span class="nav-text">生成方式的对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络编程"><span class="nav-number">3.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#网络编程基础"><span class="nav-number">3.1.</span> <span class="nav-text">网络编程基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中的网络通信"><span class="nav-number">3.2.</span> <span class="nav-text">java中的网络通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中网络相关API"><span class="nav-number">3.3.</span> <span class="nav-text">Java中网络相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InetAddress类"><span class="nav-number">3.3.1.</span> <span class="nav-text">InetAddress类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URL类"><span class="nav-number">3.3.2.</span> <span class="nav-text">URL类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于TCP的网络编程"><span class="nav-number">3.3.3.</span> <span class="nav-text">基于TCP的网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过Socket实现TCP编程"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">通过Socket实现TCP编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用多线程实现基于TCP的多客户端与服务器端通信"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">使用多线程实现基于TCP的多客户端与服务器端通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于UDP的网络编程"><span class="nav-number">3.3.4.</span> <span class="nav-text">基于UDP的网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用数据报实现UDP编程"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">使用数据报实现UDP编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用多线程实现基于UDP的多客户端与服务端连接"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">使用多线程实现基于UDP的多客户端与服务端连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络编程总结"><span class="nav-number">3.3.5.</span> <span class="nav-text">网络编程总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程"><span class="nav-number">4.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程与线程"><span class="nav-number">4.1.</span> <span class="nav-text">进程与线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中的线程"><span class="nav-number">4.2.</span> <span class="nav-text">java中的线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的常用方法："><span class="nav-number">4.2.1.</span> <span class="nav-text">线程的常用方法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承Thread类并重写run-方法"><span class="nav-number">4.2.2.</span> <span class="nav-text">继承Thread类并重写run()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承Runnable接口并实现run-方法"><span class="nav-number">4.2.3.</span> <span class="nav-text">继承Runnable接口并实现run()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行线程"><span class="nav-number">4.2.4.</span> <span class="nav-text">运行线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用多线程模拟战争"><span class="nav-number">4.3.</span> <span class="nav-text">利用多线程模拟战争</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java线程的停止"><span class="nav-number">4.4.</span> <span class="nav-text">java线程的停止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的同步与互斥"><span class="nav-number">4.5.</span> <span class="nav-text">线程的同步与互斥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的争用条件"><span class="nav-number">4.6.</span> <span class="nav-text">线程的争用条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中线程的互斥与同步"><span class="nav-number">4.7.</span> <span class="nav-text">java中线程的互斥与同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程总结"><span class="nav-number">4.8.</span> <span class="nav-text">多线程总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jdbc"><span class="nav-number">5.</span> <span class="nav-text">jdbc</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#jdbc的使用"><span class="nav-number">5.1.</span> <span class="nav-text">jdbc的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用jdbc连接MySQL数据库"><span class="nav-number">5.1.1.</span> <span class="nav-text">使用jdbc连接MySQL数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用jdbc连接oracle数据库"><span class="nav-number">5.1.2.</span> <span class="nav-text">使用jdbc连接oracle数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#jdbc调用Oracle数据库的存储过程"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">jdbc调用Oracle数据库的存储过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVC三层架构"><span class="nav-number">5.2.</span> <span class="nav-text">MVC三层架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模型层的注意事项："><span class="nav-number">5.2.1.</span> <span class="nav-text">模型层的注意事项：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制层"><span class="nav-number">5.2.2.</span> <span class="nav-text">控制层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图层"><span class="nav-number">5.2.3.</span> <span class="nav-text">视图层</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDBC各种连接方式的对比"><span class="nav-number">5.3.</span> <span class="nav-text">JDBC各种连接方式的对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java-WEB知识"><span class="nav-number">6.</span> <span class="nav-text">java WEB知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Tomcat服务器"><span class="nav-number">6.1.</span> <span class="nav-text">Tomcat服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jsp"><span class="nav-number">6.2.</span> <span class="nav-text">jsp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jsp基础语法"><span class="nav-number">6.2.1.</span> <span class="nav-text">jsp基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指令"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#脚本"><span class="nav-number">6.2.2.</span> <span class="nav-text">脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明"><span class="nav-number">6.2.3.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表达式"><span class="nav-number">6.2.4.</span> <span class="nav-text">表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jsp页面的声明周期"><span class="nav-number">6.2.5.</span> <span class="nav-text">jsp页面的声明周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jsp内置对象"><span class="nav-number">6.2.6.</span> <span class="nav-text">jsp内置对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#out对象"><span class="nav-number">6.2.6.1.</span> <span class="nav-text">out对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#request对象"><span class="nav-number">6.2.6.2.</span> <span class="nav-text">request对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#response对象"><span class="nav-number">6.2.6.3.</span> <span class="nav-text">response对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#session对象"><span class="nav-number">6.2.6.4.</span> <span class="nav-text">session对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#application对象"><span class="nav-number">6.2.6.5.</span> <span class="nav-text">application对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#page对象"><span class="nav-number">6.2.6.6.</span> <span class="nav-text">page对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pageContext对象"><span class="nav-number">6.2.6.7.</span> <span class="nav-text">pageContext对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Config对象"><span class="nav-number">6.2.6.8.</span> <span class="nav-text">Config对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exception对象"><span class="nav-number">6.2.6.9.</span> <span class="nav-text">Exception对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#javaBean"><span class="nav-number">6.2.7.</span> <span class="nav-text">javaBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jsp动作元素"><span class="nav-number">6.2.8.</span> <span class="nav-text">jsp动作元素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#与javaBean有关的动作元素"><span class="nav-number">6.2.8.1.</span> <span class="nav-text">与javaBean有关的动作元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#include动作"><span class="nav-number">6.2.8.2.</span> <span class="nav-text">include动作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forward动作"><span class="nav-number">6.2.8.3.</span> <span class="nav-text">forward动作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#param动作"><span class="nav-number">6.2.8.4.</span> <span class="nav-text">param动作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jsp状态管理"><span class="nav-number">6.2.9.</span> <span class="nav-text">jsp状态管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-WEB过滤器"><span class="nav-number">6.3.</span> <span class="nav-text">java WEB过滤器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet"><span class="nav-number">6.4.</span> <span class="nav-text">Servlet</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冰断秋</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
